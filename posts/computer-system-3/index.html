<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'U-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  computer system 3 &ndash; CastOff

    </title>
    
    
    <meta name="description" property="og:description" content="Optimization Writing an efficient program requires several type of activities. First, we must select an appropriate set of algorithms and data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient executable code. A third technique for dealing with especially demanding computations is to divide a task into portions that can be computed in parallel, on some combination of multiple cores and multiple processors.|">
    

    <meta name="apple-mobile-web-app-title" content="CastOff">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    

    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://christophe1997.github.io">
    CastOff
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item " href="/posts/">
      
      <span>Blogs</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item " href="/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">computer system 3</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/notes' class="muted-link">
  <span class="Label Label--gray-darker">notes</span>
</a>



<a href='/tags/system' class="muted-link">
  <span class="Label Label--gray">system</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-12-04. Published at: 2018-06-01.">
        
          Lastmod: 2019-12-04
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <h2 id="optimization">Optimization</h2>
<p>Writing an efficient program requires several type of activities. First, we must select an appropriate set of algorithms
and data structures. Second, we must write source code that the compiler can effectively optimize to turn into efficient
executable code. A third technique for dealing with especially demanding computations is to divide a task into portions
that can be computed in parallel, on some combination of multiple cores and multiple processors.</p>
<!-- raw HTML omitted -->
<p>And our goal in optimization is to keep modifying the source code in attempt to coax the compiler into generating efficient
code. Compared to the alternative of writing code in assembly language, this indirect approach has the advantage that
the resulting code will still run on other machines, although perhaps not with peak performance.</p>
<p>Compilers must be careful to apply only safe optimizations to a program, meaning that the the resulting program will have
the exact same behavior as would an unoptimized version for all possible cases the program may encounter.</p>
<p>The first problem is the <em>memory aliasing</em> that two pointers designate the same memory location, and in performing only
safe optimizations, the compiler must assume that different pointers may be aliased. If a compiler cannot determine whether
or not twopointers may be aliased, it must assume that either case is possible, limiting the set of possible optimizations</p>
<p>A second optimization blocker is due to function calls. It's hard to optimize the function calls with side effect, which
modifies some part of the global program state. Most compilers do not try to determine whether a function is free of side
effects, instead the compiler assumes the worse case and leaves function calls intact. Among compilers, GCC is considered
adequate, but not exceptional.</p>
<p>We introduce the metric <em>cycles per element(CPE)</em>, CPE measurements help us understand the loop performance of an iterative
program at a detailed level. The sequencing of activities by a processor is controlled by a clock providing a regular
signal of some frequency, usually expressed in <em>gigahertz(GHz)</em>, billions of cycles per second. For example, when product
literature characterizes a system as &ldquo;4 GHz&rdquo; processor, it means that the processor clock runs at 4.0E9 cycles per second,
and the period of the processor is 0.25 nanoseconds, which is the reciprocal of the clock frequency.</p>
<p>For example, consider the two programs of computing the prefix sum of a vector a:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">psum1</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="kt">float</span> <span class="n">p</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">psum2</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="kt">float</span> <span class="n">p</span><span class="p">[</span><span class="p">]</span><span class="p">,</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">i</span><span class="p">;</span> 
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">mid_val</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_val</span><span class="p">;</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_val</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>They takes 368 + 9.0n cycles and 368 + 6.0 cycles, for lagre N the run times will be dominated by the linear factors. We
refer to the coefficients in these terms as the effective number of cycle per element, so the first one's CPE is 9.0 and
the second one is 6.0.</p>
<h3 id="modern-processors">Modern processors</h3>
<p>One of the remarkable feats of modern microprocessors is they employ complex and exotic microarchitectures, in which
multiple instructions can be executed in parallel, while presenting an operational view of simple sequential instruction
execution. There are two different lower bounds characterize the maximum performance of a program. The <em>latency bound</em>
is encountered when a series of operations must performed in strict sequence, because the result of one operations is
required before the next one can begin. This bound can limit program performance when the data dependencies in the code
limit the ability of the processor to exploit instruction-level parallelism. The <em>throughput bound</em> characterizes the
raw computing capacity of the processor's functional units. This bound becomes the ultimate limit on program performance.</p>
<h3 id="trick">Trick</h3>
<ul>
<li><em>code motion</em>: Identify a computation that is performed multiple times but such that the result of the computation will
not change, and therefor move the computation to an eailer section of the code that does not get evaluated as often.</li>
<li><em>eliminate unneeded menory reference</em>: For frequent memory reference, it could be improved by introduced a temporary
variables instead of using memory referencing(pointer) in a loop.</li>
<li><em>loop unrolling</em>: Reduce the number of iterations for a loop by increasing the number of elements computed on each
iteration. It can improve performance in two ways. First, it reduces the number of operations that do not contribute
directly to the program result, such as loop indexing and conditional branching. Second, it expose ways in which we can
futher transform the code to reduce the number of operations in the cirtical paths of the overall computation.</li>
</ul>
<h2 id="the-memory-hierarchy">The memory Hierarchy</h2>
<h3 id="randomaccess-memory">Random-Access memory</h3>
<p><em>Random-access memory</em>(RAM) comes in two varieties, static and dynamic. <em>Static RAM</em>(SRAM) is faster and significantly
more expensive than <em>dynamic RAM</em>(DRAM). SRAM is used for cache memories, both on and off the CPU chip. DRAM is used for
the amin memory plus the frame buffer of a graphics system.</p>
<h3 id="readonly-memory">Read-only memory</h3>
<p><em>Read-only memory</em> can retain their information even when they are powered off, while the RAM lose their information if
the supply voltage is turned off. <em>flash memory</em> is a type of nonvolstile memory, based on EEPROM(<em>electrically erasable
programmable ROM</em>), that has become an important storage rechnology. The <em>solid state disk</em>(SSD), that provides a faster,
sturdier and less power-hungry alternative to conventional rotating disk is a new form of flash-based disk driver.</p>
<h2 id="principle-of-locality">principle of locality</h2>
<p>programs with good locality run faster than programs with poor locality. Locality is typically described as having two
distinct forms: <em>temporal locality</em> and <em>spatial locality</em>. In a program with good temporal locality, a memory location
that is referenced once is likely to be referenced again multiple times in the near future. In a program with good spatial
locality, if a memory location that is referenced once, then the program is likely to reference a nearby memory location
in the near future.</p>
<p>Consider a program of matrix multiplication(C=AxB):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="n">k</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>if we switch the loop order for j and k:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">k</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span><span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>these will not change the result, but the second improves efficiency. Because the second has no cache missing.</p>
<ul>
<li>Programs that repeatedly reference the same variables enjoy good temporal locality.</li>
<li>For programs with stride-k reference patterns, the smaller the stride the better the spatial locality. Programs with
stride-1 reference patterns have good spatial locality. Programs that hop around memory with large strides have poor
spatial locality.</li>
<li>Loops have good temporal and spatial locality with respect to instruction fetches. The smaller the loop body and the
greater the number of loopiterations, the better the locality.</li>
</ul>

  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>computer system 3</b><nav id="TableOfContents">
  <ul>
    <li><a href="#optimization">Optimization</a>
      <ul>
        <li><a href="#modern-processors">Modern processors</a></li>
        <li><a href="#trick">Trick</a></li>
      </ul>
    </li>
    <li><a href="#the-memory-hierarchy">The memory Hierarchy</a>
      <ul>
        <li><a href="#randomaccess-memory">Random-Access memory</a></li>
        <li><a href="#readonly-memory">Read-only memory</a></li>
      </ul>
    </li>
    <li><a href="#principle-of-locality">principle of locality</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©Christophe &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
