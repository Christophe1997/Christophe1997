<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-112755173-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  Haskell Algebra &ndash; CastOff

    </title>
    
    
    <meta name="description" property="og:description" content="Semigroup 半群即一个集合以及在之上定义的一个满足结合律的二元运算, 在Haskell中定义为(部分): 1 2 3 class Semigroup where (&amp;lt;&amp;gt;) :: a -&amp;gt; a -&amp;gt; a {-# MINIMAL (&amp;lt;&amp;gt;) #-} Laws 1 2 -- associativity a &amp;lt;&amp;gt;|">
    

    <meta name="apple-mobile-web-app-title" content="CastOff">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    

    <meta name="msvalidate.01" content="A66009ECF32987EBBB7783F428A03342" />
    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://christophe1997.github.io">
    CastOff
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item " href="/posts/">
      
      <span>Blogs</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item " href="/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">Haskell Algebra</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/language-concepts' class="muted-link">
  <span class="Label Label--gray-darker">Language concepts</span>
</a>



<a href='/tags/haskell' class="muted-link">
  <span class="Label Label--gray">Haskell</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2020-03-17. Published at: 2019-03-24.">
        
          Lastmod: 2020-03-17
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <h2 id="semigroup-">Semigroup</h2>
<p>半群即一个集合以及在之上定义的一个满足结合律的二元运算, 在Haskell中定义为(部分):</p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Semigroup</span> <span class="kr">where</span>
  <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
  <span class="cm">{-# MINIMAL (&lt;&gt;) #-}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="laws-">Laws</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- associativity</span>
<span class="nf">a</span> <span class="o">&lt;&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">c</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="monoid-">Monoid</h2>
<p>&ldquo;A monoid is a binary associative operation with an identity&rdquo;, 在Haskell中定义为(部分):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">mempty</span> <span class="ow">::</span> <span class="n">m</span>
  <span class="n">mappend</span> <span class="ow">::</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span>
  <span class="n">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span>
  <span class="n">mconcat</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">mappend</span> <span class="n">mempty</span>
  <span class="cm">{-# MINIMAL mempty #-}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="laws--1">Laws</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- left identity</span>
<span class="nf">mappend</span> <span class="n">menpty</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>

<span class="c1">-- right identity</span>
<span class="nf">mappend</span> <span class="n">x</span> <span class="n">mempty</span> <span class="ow">=</span> <span class="n">x</span>

<span class="c1">-- associativity</span>
<span class="nf">mappend</span> <span class="n">x</span> <span class="p">(</span><span class="n">mappend</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mappend</span> <span class="p">(</span><span class="n">mappend</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">z</span>
</code></pre></td></tr></table>
</div>
</div><p>这和数学上带幺半群所满足的性质是一致的, 带幺半群即一个包含单位元的半群.</p>
<h2 id="functor-">Functor</h2>
<p>Functor最初由逻辑学家Rudolf Carnap在1930s引入, 其接受一个<em>sentence</em>(<em>phrase</em>)作为输入, 并生成一个<em>sentence</em>(<em>phrase</em>)作为输出. Functor在Haskell中定义为(部分):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- 易见一个Functor的kind必为`* -&gt; *`</span>
<span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
  <span class="cm">{-# MINIMAL fmap #-}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>fmap</code>的中缀运算符为<code>&lt;$&gt;</code>.</p>
<h3 id="laws--2">Laws</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- identity</span>
<span class="nf">fmap</span> <span class="n">id</span> <span class="ow">=</span> <span class="n">id</span>

<span class="c1">-- Composition</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="n">f</span> <span class="o">.</span> <span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">fmap</span> <span class="n">f</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span>
</code></pre></td></tr></table>
</div>
</div><p>Functor是可堆叠的(<em>stacked</em>), 对于多个Functor嵌套的类型，可以通过多次复合fmap来获得对应不同层级的fmap:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span><span class="p">)</span>
<span class="p">(</span><span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span><span class="p">)</span>
  <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f1</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">f2</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f1</span> <span class="p">(</span><span class="n">f2</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f1</span> <span class="p">(</span><span class="n">f2</span> <span class="n">b</span><span class="p">)</span>
  
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span><span class="p">)</span>
<span class="p">(</span><span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span> <span class="o">.</span> <span class="n">fmap</span><span class="p">)</span>
  <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f1</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">f2</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">f3</span><span class="p">)</span> <span class="ow">=&gt;</span>
     <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f1</span> <span class="p">(</span><span class="n">f2</span> <span class="p">(</span><span class="n">f3</span> <span class="n">a</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">f1</span> <span class="p">(</span><span class="n">f2</span> <span class="p">(</span><span class="n">f3</span> <span class="n">b</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>简单的推导:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>.<span class="o">)</span> :: <span class="o">(</span>b -&gt; c<span class="o">)</span> -&gt; <span class="o">(</span>a -&gt; b<span class="o">)</span> -&gt; a -&gt; c
fmap :: <span class="o">(</span>m -&gt; n<span class="o">)</span> -&gt; f m -&gt; f n
fmap :: <span class="o">(</span>x -&gt; y<span class="o">)</span> -&gt; g x -&gt; g <span class="nv">y</span>
<span class="o">=</span>&gt; 
<span class="o">(</span>m -&gt; n<span class="o">)</span> &lt;<span class="o">=</span>&gt; b
<span class="o">(</span>f m -&gt; f n<span class="o">)</span> &lt;<span class="o">=</span>&gt; c
<span class="o">(</span>x -&gt; y<span class="o">)</span> &lt;<span class="o">=</span>&gt; a
<span class="o">(</span>g x -&gt; g y<span class="o">)</span> &lt;<span class="o">=</span>&gt; <span class="nv">b</span>
<span class="o">=</span>&gt;
<span class="o">(</span>m -&gt; n<span class="o">)</span> &lt;<span class="o">=</span>&gt; <span class="o">(</span>g x -&gt; g y<span class="o">)</span>
<span class="o">=</span>&gt; 
m &lt;<span class="o">=</span>&gt; g x and n &lt;<span class="o">=</span>&gt; g <span class="nv">y</span>
<span class="o">=</span>&gt;
<span class="o">(</span>fmap . fmap<span class="o">)</span> &lt;<span class="o">=</span>&gt; a -&gt; c
			  &lt;<span class="o">=</span>&gt; <span class="o">(</span>x -&gt; y<span class="o">)</span> -&gt; <span class="o">(</span>f m -&gt; f n<span class="o">)</span>
              &lt;<span class="o">=</span>&gt; <span class="o">(</span>x -&gt; y<span class="o">)</span> -&gt; <span class="o">(</span>f g x -&gt; f g y
</code></pre></td></tr></table>
</div>
</div><h3 id="io-functor-">IO Functor</h3>
<p>Haskell的IO是Haskell关键设计之一, 由于其没有构造器, 因此只能使用IO typeclass所提供的来处理<code>IO a</code>, 其中最简单的处理之一是Functor.
例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- read :: Read a =&gt; String -&gt; a</span>
<span class="c1">-- getLine :: IO String</span>
<span class="nf">getInt</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">getInt</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">read</span> <span class="n">getLine</span>
</code></pre></td></tr></table>
</div>
</div><p><code>getLine</code>应当看成是获取String的方法(<em>a way to obtain a string</em>), IO不确保副作用会被执行, 而是确保副作用可以被执行. 我们可以用<code>fmap</code>对输入做任何处理:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">getInt</span>
<span class="mi">1</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>这和do notation是一致的:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">incIt</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">int</span>
<span class="nf">incIt</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">input</span> <span class="ow">&lt;-</span> <span class="n">getInt</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">input</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="applicative-">Applicative</h2>
<p>Applicative是monoidal functor, 其在Haskell中定义为(部分):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
<span class="nf">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>  <span class="c1">-- apply</span>
<span class="cm">{-# MINIMAL pure, ((&lt;*&gt;) | liftA2) #-}</span>

<span class="c1">-- 定义fmap</span>
<span class="nf">fmap</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">x</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="laws--3">Laws</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- idenitity</span>
<span class="nf">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">v</span>

<span class="c1">-- Composition</span>
<span class="nf">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span><span class="p">)</span>

<span class="c1">-- Homomorphism</span>
<span class="nf">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>

<span class="c1">-- Interchange</span>
<span class="nf">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="monad-">Monad</h2>
<p>Monad是Haskell中讨论最多的结构, 但严格来讲Monad对于Haskell并不是必须的(<em>Haskell Programming From First Principle</em> p745). 当前的Haskell确实使用Monad来构成和转换IO动作, 但更早的Haskell并不是.</p>
<p>Monad是applicative functor, 但有一些唯一的特性使得其比applicative或functor更强大, 其在haskell中定义为(部分):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>  <span class="c1">-- bind </span>
<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="cm">{-# MINIMAL (&gt;&gt;=) #-}</span>

<span class="c1">-- 定义fmap</span>
<span class="nf">fmap</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">.</span> <span class="n">f</span>
</code></pre></td></tr></table>
</div>
</div><p>因此, 任何Monad的实例都必须是Applicative和Functor的实例.</p>
<h3 id="laws--4">Laws</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- left identity</span>
<span class="nf">return</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="c1">-- right identity</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="ow">=</span> <span class="n">m</span>

<span class="c1">-- associativity</span>
<span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="monad与计算-">Monad与计算</h3>
<p>一种Monad定义了一种计算类型, <code>return</code>用来构造该计算类型的值, <code>bind</code>用来组合这些计算以构建更为复杂的计算. 例如, <code>Maybe</code>Monad定义了可能不返回任何值的计算, 而<code>List</code>Monad则定义了模糊计算, 即返回结果包含多个值的计算.</p>
<p>Haskell的do-notation允许使用命令式的风格来写monadic计算, Monad计算的值可以通过<code>&lt;-</code>来&quot;绑定&rdquo;(do-notation中才能使用), 例如<code>x:xs &lt;- Just [1, 2, 3]</code>, <code>x:xs</code>会匹配<code>[1, 2, 3]</code>. 一个do-notation的块也可以使用分号和大括号, 例如<code>do {a &lt;- Just 2; b &lt;- Just 3; ...}</code>. 因此, do-notation很像命令式编程, 虽然其只是语法糖, 例如你可以将<code>x &lt;- expr1</code>写成<code>expr1 &gt;&gt;= \x -&gt;</code>, 没有绑定的<code>expr2</code>写成<code>expr2 &gt;&gt;= \_ -&gt;</code>, 可见相比与不使用do-notation, 其要方便很多, 可以说是很甜了.</p>
<p>Haskell的Monad的定义中还包含了两个函数, <code>fail</code>和<code>&gt;&gt;</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fail</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">fail</span> <span class="n">s</span> <span class="ow">=</span> <span class="ne">error</span> <span class="n">s</span>

<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">m</span> <span class="o">&gt;&gt;</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">k</span>
</code></pre></td></tr></table>
</div>
</div><p><code>fail</code>函数在do-block中模式匹配失败时被调用:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- fn 1会调用fail直接返回Nothing</span>
<span class="c1">-- fail _ = Nothing</span>
<span class="nf">fn</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">fn</span> <span class="n">idx</span> <span class="ow">=</span> <span class="kr">do</span> <span class="kr">let</span> <span class="n">l</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Just</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="kt">Nothing</span><span class="p">]</span>
            <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">l</span><span class="o">!!</span><span class="n">idx</span>   <span class="c1">-- a pattern match failure will call &#34;fail&#34;</span>
            <span class="n">return</span> <span class="n">xs</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="monadplus-">MonadPlus</h3>
<p>除了上述三条基本的规则以外, 一些Monad还符合额外的规则, 这些Monad有一个<code>mzero</code>和<code>mplus</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- mzero类似0</span>
<span class="c1">-- mplus类似加法</span>
<span class="c1">-- &gt;&gt;=类似乘法</span>
<span class="nf">mzero</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">==</span> <span class="n">mzero</span>
<span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">mzero</span> <span class="o">==</span> <span class="n">mzero</span>
<span class="nf">mzero</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">m</span> <span class="o">==</span> <span class="n">m</span>
<span class="nf">m</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">mzero</span> <span class="o">==</span> <span class="n">m</span>
</code></pre></td></tr></table>
</div>
</div><p>Haskell中这样的Monad可以实例化<code>MonadPlus</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- 构成了一个加法群</span>
<span class="kr">class</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadPlus</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">mzero</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span>
  <span class="n">mplus</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="foldable">Foldable</h2>
<p>对Foldable最恰当的描述应该是其官方文档的描述: &ldquo;class of data structures that can be folded to a summary value&rdquo;, 其在Haskell中定义为(部分):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Foldable</span> <span class="p">(</span><span class="n">t</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fold</span> <span class="ow">::</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span>  <span class="c1">-- Data.Foldable.fold</span>
  <span class="n">foldMap</span> <span class="ow">::</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span>
  <span class="n">foldr</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
  <span class="n">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
  <span class="cm">{-# MINIMAL foldMap | foldr #-}</span>
</code></pre></td></tr></table>
</div>
</div><p>另外还有一些基本的操作:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- List element of a structure from left to right</span>
<span class="c1">-- import Data.Foldable</span>
<span class="nf">toList</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="c1">-- Test whether the structure is empty</span>
<span class="nf">null</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">-- Return the size of a finite structure</span>
<span class="nf">length</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>

<span class="c1">-- Does the element occur in the structure</span>
<span class="nf">elem</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">-- The lagest element of a non-empty structure</span>
<span class="nf">maximum</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="c1">-- The least element of a non-empty structure</span>
<span class="nf">minimum</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>

<span class="nf">sum</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">product</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</code></pre></td></tr></table>
</div>
</div><p>一个不明显的例子:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">length</span> <span class="kt">Just</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>此处<code>fmap</code>作用在<code>Just :: a -&gt; Maybe a</code>上, 即作用在<code>(-&gt;) a Maybe a</code>上, 而<code>(-&gt;)</code>的<code>fmap = (.)</code>(<a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-693">source</a>), 因此<code>fmap length Just == (length . Just)</code>.</p>
<h2 id="traversable">Traversable</h2>
<p>Traversable依赖于Applicative, 因此也依赖与Functor, 并且是Foldable的升级版:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">t</span><span class="p">,</span> <span class="kt">Foldable</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Traversable</span> <span class="n">t</span> <span class="kr">where</span>
  <span class="c1">-- mapM is traverse</span>
  <span class="n">traverse</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">traverse</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">sequenceA</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">f</span>
  
  <span class="c1">-- Evaluate each action in the structure from left to right</span>
  <span class="c1">-- and collect the results</span>
  <span class="c1">-- sequence is sequenceA</span>
  <span class="n">sequenceA</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">sequenceA</span> <span class="ow">=</span> <span class="n">traverse</span> <span class="n">id</span>
  <span class="cm">{-# MINIMAL traverse | sequenceA #-}</span>
</code></pre></td></tr></table>
</div>
</div><p>Traversable可以用来翻转两个类型构造器, 或者先map在翻转.</p>
<h3 id="laws">Laws</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- traverse function</span>
<span class="c1">-- Naturality</span>
<span class="nf">t</span> <span class="o">.</span> <span class="n">traverse</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">traverse</span> <span class="p">(</span><span class="n">t</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>

<span class="c1">-- Identity</span>
<span class="nf">traverse</span> <span class="kt">Identity</span> <span class="ow">=</span> <span class="kt">Identity</span>

<span class="c1">-- Composition</span>
<span class="nf">traverse</span> <span class="p">(</span><span class="kt">Compose</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">g</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Compose</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">traverse</span> <span class="n">g</span><span class="p">)</span> <span class="o">.</span> <span class="n">traverse</span> <span class="n">f</span>

<span class="c1">-- sequenceA function</span>
<span class="c1">-- Naturality</span>
<span class="nf">t</span> <span class="o">.</span> <span class="n">sequenceA</span> <span class="ow">=</span> <span class="n">sequenceA</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">t</span>

<span class="c1">-- Identity</span>
<span class="nf">sequenceA</span> <span class="o">.</span> <span class="n">fmap</span> <span class="kt">Identity</span> <span class="ow">=</span> <span class="kt">Identity</span>

<span class="c1">-- Composition</span>
<span class="nf">sequence</span> <span class="o">.</span> <span class="n">fmap</span> <span class="kt">Compose</span> <span class="ow">=</span> <span class="kt">Compose</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">sequenceA</span> <span class="o">.</span> <span class="n">sequenceA</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="--r-as-functor-applicative-and-monad"><code>(-&gt;) r</code> as Functor, Applicative and Monad</h2>
<p><code>(-&gt;)</code>通常称为函数箭头或者函数类型构造器, 因此<code>(-&gt;) r</code>的kind为<code>* -&gt; *</code>, 于是其也可以实例化Functor, Applicative以及Monad(Reader):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fmap</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>
  
<span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">pure</span> <span class="ow">=</span> <span class="n">const</span>
  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">liftA2</span> <span class="n">q</span> <span class="n">f</span> <span class="n">g</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">q</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
  
<span class="c1">-- Reader also</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="p">(</span><span class="n">f</span> <span class="n">r</span><span class="p">)</span> <span class="n">r</span>
</code></pre></td></tr></table>
</div>
</div>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>Haskell Algebra</b><nav id="TableOfContents">
  <ul>
    <li><a href="#semigroup-">Semigroup</a>
      <ul>
        <li><a href="#laws-">Laws</a></li>
      </ul>
    </li>
    <li><a href="#monoid-">Monoid</a>
      <ul>
        <li><a href="#laws--1">Laws</a></li>
      </ul>
    </li>
    <li><a href="#functor-">Functor</a>
      <ul>
        <li><a href="#laws--2">Laws</a></li>
        <li><a href="#io-functor-">IO Functor</a></li>
      </ul>
    </li>
    <li><a href="#applicative-">Applicative</a>
      <ul>
        <li><a href="#laws--3">Laws</a></li>
      </ul>
    </li>
    <li><a href="#monad-">Monad</a>
      <ul>
        <li><a href="#laws--4">Laws</a></li>
        <li><a href="#monad与计算-">Monad与计算</a></li>
        <li><a href="#monadplus-">MonadPlus</a></li>
      </ul>
    </li>
    <li><a href="#foldable">Foldable</a></li>
    <li><a href="#traversable">Traversable</a>
      <ul>
        <li><a href="#laws">Laws</a></li>
      </ul>
    </li>
    <li><a href="#--r-as-functor-applicative-and-monad"><code>(-&gt;) r</code> as Functor, Applicative and Monad</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©Christophe &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
