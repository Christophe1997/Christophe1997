<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>排序算法 | CastOff</title><meta name=keywords content="Java"><meta name=description content="排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销 和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.
我们使用的算法模板如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public interface Sort { static void sort(Comparable[] a) { } static boolean less(Comparable v, Comparable w) { return v.compareTo(w) < 0; } static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } static void show(Comparable[] a) { for (Comparable x : a) { StdOut."><meta name=author content="Christophe"><link rel=canonical href=https://christophe1997.github.io/posts/2018/sorting-algorithms/><meta name=google-site-verification content="CastOff"><link href=https://christophe1997.github.io/assets/css/stylesheet.min.6f4392ae929a8a0f8c40646695f332c58db4df0d0d1a54ddae9f5f2625a677f3.css integrity="sha256-b0OSrpKaig+MQGRmlfMyxY203w0NGlTdrp9fJiWmd/M=" rel="preload stylesheet" as=style><link rel=icon href=https://christophe1997.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://christophe1997.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://christophe1997.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://christophe1997.github.io/apple-touch-icon.png><link rel=mask-icon href=https://christophe1997.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-112755173-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="排序算法"><meta property="og:description" content="排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销 和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.
我们使用的算法模板如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public interface Sort { static void sort(Comparable[] a) { } static boolean less(Comparable v, Comparable w) { return v.compareTo(w) < 0; } static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } static void show(Comparable[] a) { for (Comparable x : a) { StdOut."><meta property="og:type" content="article"><meta property="og:url" content="https://christophe1997.github.io/posts/2018/sorting-algorithms/"><meta property="article:published_time" content="2018-03-30T12:07:09+00:00"><meta property="article:modified_time" content="2018-03-30T12:07:09+00:00"><meta property="og:site_name" content="CastOff"><meta name=twitter:card content="summary"><meta name=twitter:title content="排序算法"><meta name=twitter:description content="排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销 和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.
我们使用的算法模板如下
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public interface Sort { static void sort(Comparable[] a) { } static boolean less(Comparable v, Comparable w) { return v.compareTo(w) < 0; } static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } static void show(Comparable[] a) { for (Comparable x : a) { StdOut."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"排序算法","name":"排序算法","description":"排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销 和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.\n我们使用的算法模板如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 …","keywords":["Java"],"articleBody":"排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销 和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.\n我们使用的算法模板如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public interface Sort { static void sort(Comparable[] a) { } static boolean less(Comparable v, Comparable w) { return v.compareTo(w)  0; } static void exch(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } static void show(Comparable[] a) { for (Comparable x : a) { StdOut.print(x + \" \"); StdOut.println(); } } static boolean isSorted(Comparable[] a) { for (int i = 1; i  a.length; i++) { if (less(a[i], a[i - 1])) return false; } return true; } static void main(String[] args) { String[] a = StdIn.readAllStrings(); sort(a); assert isSorted(a); show(a); } }   选择排序 最简单的算法是选择排序, 不断寻找数组剩下元素的最小值, 并将其放在适当的位置. 其特点在于:\n 运行时间与输入无关. 数据移动最少, 交换次数和数组大小是线性关系, 其他算法大都是线性对数或者平方级别的.  1 2 3 4 5 6 7 8 9 10  public static void sort(Comparable[] a) { int N = a.length; for (int i = 0; i  N; i++) { int min = i; for (int j = i + 1; j  N; j++) { if (Sort.less(a[j], a[min])) min = j; Sort.exch(a, i, min); } } }   对于长度为N的数组, 选择排序大约需要$ N^2/2 $次比较和N次交换.\n插入排序 对于随机排列长度为N且主键不重复的数组, 平均情况下插入排序需要$ \\sim N^2/4 $次比较以及$ \\sim N^2/4 $次交换. 最坏情况下, 比较和交换的次数 都为$ \\sim N^2/2 $, 最好的情况下需要N-1次比较和0次交换.\n1 2 3 4 5 6 7 8  public static void sort(Comparable[] a) { int N = a.length; for (int i = 1; i  N; i++) { for (int j = i; j  0 \u0026\u0026 Sort.less(a[j], a[j-1]); j--) { Sort.exch(a, j, j-1); } } }   倒置是指数组中两个顺序颠倒的元素, 例如\"E A\"中E-A就是一对倒置, 如果数组中倒置的数量小于数组大小的某个倍数, 则称该数组为部分有序. 部分有序有以下 几种典型情况:\n 数组中每个元素距离它的最终位置都不远. 一个有序的大数组接一个小数组. 数组中只有几个元素的位置不正确.  插入排序对这样的数组很有效, 当倒置数量很少时, 插入排序可能比其他任何排序都快. 事实上, 设长度为N的数组的倒置数量为m, 则插入排序需要的交换操作等于m, 需要的比较次数大于等于m, 小于等于m+N-1.\n对于随机排序的无重复主键的数组, 插入排序和选择排序的运行时间是平方级别的, 两者之比应该是一个较小的常数.\n希尔排序 希尔排序简单的改进了插入排序, 其思想是使数组中任意间隔为h的元素都是有序的, 这样的数组称为h有序数组. 一个h有序数组指的是h个互相独立的数组交错在一起 的数组, 当h很大时, 就能把元素移到较远的位置. 对于任意以1结尾的h序列, 数组都能够排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public static void sort(Comparable[] a) { int N = a.length; int h = 1; // 使用序列1/2 (3^k - 1)  while (h  N/3) h = 3 * h + 1; while (h = 1) { for (int i = h; i  N; i++) { for (int j = i; j = h \u0026\u0026 Sort.less(a[j], a[j - h]); j -= h) { Sort.exch(a, j, j - h); } } h /= 3; } }   算法的性能取决于h序列的选择, 我们选择的序列在最坏的情况下与$ N^{3/2} $成正比. 其他算法在N不是特别大的情况下, 大约只比希尔排序快2倍左右.\n归并排序 归并排序保证任意长度为N的数组排序所需的时间和NlgN成正比, 它的主要缺点是所需的额外空间也和N成正比.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 自顶向下 public static void sort(Comparable[] a) { int N = a.length; // 辅助数组  aux = new Comparable[N]; sort(a, 0, N - 1); } public static void sort(Comparable[] a, int lo, int hi) { if (hi  lo) return; int mid = lo + (hi - lo)/2; sort(a, lo, mid); sort(a, mid + 1, hi); merge(a, lo, mid, hi); } public static void merge(Comparable[] a, int lo, int mid, int hi) { int i = lo; int j = mid + 1; for (int k = lo; k  hi; k++) aux[k] = a[k]; for (int k = lo; k  hi; k++) { if (i  mid) a[k] = aux[j++]; else if (j  hi) a[k] = aux[i++]; else if (Sort.less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; } }   对于长度为N的数组, 自顶向下的归并排序需要1/2NlgN到NlgN次比较.\n 证明: 令C(N)表示将一个长度为N的数组排序所需要的比较次数, 我们容易得到$ C(0)=C(1)=0 $, 对于N1的情况有: $$ C(N) \\le C(\\lceil N/2 \\rceil) + C(\\lfloor N/2 \\rfloor) + N $$ 以及: $$ C(N) \\ge C(\\lceil N/2 \\rceil) + C(\\lfloor N/2 \\rfloor) + N/2 $$ 当$ N=2^{n} $时, 有解: $$ C(2^n)/2^n = C(2^0)/2^0 + n = n $$ 两边同时乘以$ 2^n $并代回N,有: $$ C(N) = C(2^n) = n \\times 2^n = NlgN $$\n 同理, 自顶向下的归并排序最多需要访问数组6NlgN.\n用不同的方法处理小规模问题能改进大多数递归算法的性能, 因为递归会使小规模问题中方法的调用过于频繁, 从而改进对它们的处理方法能够改进整个算法. 在归并 算法中, 使用插入排序来处理小规模的子数组一般能将运行时间缩短10%~15%. 而通过测试数组是否有序可以将任何有序的子数组运行时间变为线性.\n排序算法的复杂度 我们研究的排序算法是基于比较的(忽略了访问数组的开销), 一个基于比较的算法在两次比较之间可能会进行任意规模的计算, 但它们只能通过主键之间的比较来得到关 于某个主键的信息.\n没有任何基于比较的算法能够保证使用少于~NlgN(lgN!)次比较将长度为N的数组排序.\n 证明: 假设数组没有重复的主键, 用二叉树来表示所有可能的情况. 那么叶子数最少是N!, 因为对于N个不同的主键有N!种不同的排列, 于是任何基于比较的 排序算法都对应着一颗高为h的二叉树, 其中: $$ N! \\le 叶子数 \\le 2^h $$ 而算法的复杂度对应与根节点到叶子的路径长, 即 $ T \\ge lgN! $, 根据斯特灵公式有lgN! ~NlgN.\n 上述论证意味着, 没有任何排序算法能够用少于~NlgN次比较将数组排序, 归并排序是一种渐进最优的基于比较排序的算法. 但在实际情况中:\n 归并排序的空间复杂度不是最优的. 在实践中不一定是最坏的情况. 算法的其他操作也可能成为关键所在. 不进行比较也能够将某些数组排序.  快速排序 快速排序的特点包括原地排序(只需要一个很小的辅助栈), 且将长度为N的数组排序的时间和NlgN成正比. 另外, 快速排序的内循环比大多数排序算法都小. 它的主要 缺点在于非常脆弱, 实现时要避免低劣的性能. 快速排序的效率依赖于切分数组的效果, 即依赖于切分数组的值.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //简单的实现 public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length); } private static void sort(Comparable[] a, int lo, int hi) { if (hi  lo) return; int j = partition(a, lo, hi); sort(a, lo, j); sort(a, j + 1, hi); } private static int partition(Comparable[] a, int lo, int hi) { if (lo == hi) return lo; int i = lo, j = hi + 1; Comparable v = a[lo]; while (true) { while (Sort.less(a[++i], v)) if (i == hi) break; while (Sort.less(v, a[--j])) if (j == lo) break; if (i  j) break; Sort.exch(a, i, j); } Sort.exch(a, lo, j); return j; }   快速排序的最好情况是每次都正好能将数组对半分, 此时满足分治递归的$ C_N = 2C_{N/2} + N $公式, 这样得到的解是NlgN. 平均而言, 切分元素都能够落在 数组的中间.\n将长度为N的无重复数组排序, 快速排序平均需要~2NlgN次比较.\n 证明: 令$ C_k $为将N个不同元素排序平均需要的比较次数, 显然有$ C_0=C_1=0 $, 对于N1的情况, 可得到以下递归关系: $$ C_N = N + 1 + (C_0 + C_1 + \\cdots + C_{N-2} + C_{N-1})/N + (C_{N-1} + C_{N-2} + \\cdots + C_0)/N $$ 其中第一项是切分成本, 总是N+1, 后面两项是左右子数组排序的平均成本, 等式两边同乘以N得到: $$ NC_N = N(N+1) + 2(C_0 + C_1 + \\cdots + C_{N-1}) $$ 即: $$ NC_N - (N-1)C_{N-1} = 2N + 2C_{N-1} $$ 进而得到: $$ C_N/(N+1) = C_{N-1}/N + 2/(N+1) $$ 于是有$ C_N/(N+1) - C_1/2 = 2(1/3 + 1/4 + \\cdots + 1/(N+1)) $, 即$ C_N = 2(N+1)(1/3 + 1/4 + \\cdots + 1/(N+1)) $ 近似的得到$ C_N \\approx 2NlnN \\approx 1.39NlgN $, 即平均的比较次数比最好的情况多39%.\n 上述简单的快速排序有一个潜在的缺点, 即在切分不平衡时, 可能会极为低效, 在最坏的情况下快速排序需要$ N^2/2 $次比较, 我们在排序前shuffle数组就是为了 减少这种情况的发生.\n改进  适时切换到插入排序 和大多数递归算法一样, 对于小数组快速排序比插入排序更慢, 在数组长度为5~15之间选择插入排序通常能取得较好的效果. 三取样切分 使用子数组的一小部分元素的中位数来切分数组, 这样能得到更好的切分, 但需要额外计算中位数的代价, 当取样大小为3时切分效果最好, 还可以放置哨兵来取消 边界检测. 熵最优排序 当数组中含有大量重复元素的时候, 对于元素全部重复的元素可以不再排序. 一个简单的办法是将数组切分为三部分(荷兰国旗问题).  三向切分的快速排序 E. W. Dijkstra提出的三向切分解法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static void sort(Comparable[] a) { StdRandom.shuffle(a); sort(a, 0, a.length - 1); } @SuppressWarnings(\"unchecked\") private static void sort(Comparable[] a, int lo, int hi) { if (hi  lo) return; int lt = lo, i = lo + 1, gt = hi; Comparable v = a[lo]; while (i  gt) { int cmp = a[i].compareTo(v); if (cmp  0) Sort.exch(a, lt++, i++); else if (cmp  0) Sort.exch(a, gt--, i); else i++; } sort(a, lo, lt - 1); sort(a, gt + 1, hi); }   对于只有若干不同主键的随机数组, 三向切分快速排序能够达到线性级别. 给定包含k个不同值的N个主键, 定义$ f_i $为第i个主键出现的次数, $ p_i = f_i/N $ 即第i个主键出现的概率, 那么香农熵定义为: $$ H = -(p_1lgp_1 + p_2lgp_2 + \\cdots + p_klgp_k) $$ 可以得到:\n 不存在任何基于比较的算法能够保证在NH-N次比较内将N个元素排序. 对于大小为N的数组, 三向切分的快速排序需要~(2ln2)NH次比较.  当不存在重复主键时, $ H=lgN $, 而有重复主键时, 其具有更好的性能. 这两个性质说明了三向切分的快速排序是信息最优的.\n堆排序 堆排序首先构造一个堆, 然后使用下沉操作将数组按升序排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public static void sort(Comparable[] a) { int N = a.length; for (int k = N / 2; k = 1; k--) sink(a, k, N); while (N  1) { exch(a, 1, N--); sink(a, 1, N); } } private static boolean less(Comparable[] a, int i, int j) { return a[i - 1].compareTo(a[j - 1])  0; } private static void exch(Comparable[] a, int i, int j) { Comparable t = a[i - 1]; a[i - 1] = a[j - 1]; a[j - 1] = t; } private static void sink(Comparable[] a, int k, int N) { while (2 * k  N) { int j = 2 * k; if (j  N \u0026\u0026 less(a, j, j + 1)) j++; if (!less(a, k, j)) break; exch(a, k, j); k = j; } }   将N个元素排序, 堆排序需要(2NlgN+2N)次比较(2N来源于堆的构造). 堆排序在排序复杂性的研究中具有重要地位, 因为它是唯一一个能够同时最优地利用空间和时间 的方法, 在最坏的情况下它也能保证~2NlgN次比较和恒定的空间. 在空间紧张的场景下具有很好的效果, 但却很少被现代操作系统的其他应用采用, 因为其无法利用缓 存.\n常用排序算法的比较    算法 稳定性 原地 时间复杂度 空间复杂度     选择排序 否 是 $ N^2 $ 1   插入排序 是 是 N到$ N^2 $ 1   希尔排序 否 是 $ N^{3/2} $ 1   快速排序 否 是 NlgN lgN   三向快速排序 否 是 N到lgN lgN   归并排序 是 否 NlgN N   堆排序 否 是 NlgN 1    大多数情况下快速排序是最佳选择; 如果需要稳定性且空间充足的情况下, 归并排序是很好的选择; 对于原始的数据, 直接操作数据排序更合适.\n","wordCount":"1323","inLanguage":"en","datePublished":"2018-03-30T12:07:09Z","dateModified":"2018-03-30T12:07:09Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://christophe1997.github.io/posts/2018/sorting-algorithms/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"https://christophe1997.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://christophe1997.github.io accesskey=h>CastOff</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://christophe1997.github.io/tags/><span>Tags</span></a></li><li><a href=https://christophe1997.github.io/categories/><span>Categories</span></a></li><li><a href=https://christophe1997.github.io/archives/><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>排序算法</h1><div class=post-meta>March 30, 2018&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><p>排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外内存开销
和运行时间是同等重要的, 排序算法可以分为原地排序算法以及需要额外内存空间来存储另一份数组副本的其他排序算法.</p><p>我们使用的算法模板如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Sort</span> <span class=o>{</span>
    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=o>}</span>

    <span class=kd>static</span> <span class=kt>boolean</span> <span class=nf>less</span><span class=o>(</span><span class=n>Comparable</span> <span class=n>v</span><span class=o>,</span> <span class=n>Comparable</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>v</span><span class=o>.</span><span class=na>compareTo</span><span class=o>(</span><span class=n>w</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>exch</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>Comparable</span> <span class=n>t</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
        <span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
        <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>show</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>Comparable</span> <span class=n>x</span> <span class=o>:</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>StdOut</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>x</span> <span class=o>+</span> <span class=s>&#34; &#34;</span><span class=o>);</span>
            <span class=n>StdOut</span><span class=o>.</span><span class=na>println</span><span class=o>();</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>static</span> <span class=kt>boolean</span> <span class=nf>isSorted</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>less</span><span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>a</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>1</span><span class=o>]))</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>String</span><span class=o>[]</span> <span class=n>a</span> <span class=o>=</span> <span class=n>StdIn</span><span class=o>.</span><span class=na>readAllStrings</span><span class=o>();</span>
        <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
        <span class=k>assert</span> <span class=n>isSorted</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
        <span class=n>show</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h2 id=选择排序>选择排序<a hidden class=anchor aria-hidden=true href=#选择排序>#</a></h2><p>最简单的算法是选择排序, 不断寻找数组剩下元素的最小值, 并将其放在适当的位置. 其特点在于:</p><ul><li>运行时间与输入无关.</li><li>数据移动最少, 交换次数和数组大小是线性关系, 其他算法大都是线性对数或者平方级别的.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>min</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span> <span class=o>{</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>Sort</span><span class=o>.</span><span class=na>less</span><span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>],</span> <span class=n>a</span><span class=o>[</span><span class=n>min</span><span class=o>]))</span> <span class=n>min</span> <span class=o>=</span> <span class=n>j</span><span class=o>;</span>
            <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>min</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>对于长度为N的数组, 选择排序大约需要$ N^2/2 $次比较和N次交换.</p><h2 id=插入排序>插入排序<a hidden class=anchor aria-hidden=true href=#插入排序>#</a></h2><p>对于随机排列长度为N且主键不重复的数组, 平均情况下插入排序需要$ \sim N^2/4 $次比较以及$ \sim N^2/4 $次交换. 最坏情况下, 比较和交换的次数
都为$ \sim N^2/2 $, 最好的情况下需要N-1次比较和0次交换.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=n>0</span> <span class=o>&amp;&amp;</span> <span class=n>Sort</span><span class=o>.</span><span class=na>less</span><span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>],</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>-</span><span class=n>1</span><span class=o>]);</span> <span class=n>j</span><span class=o>--)</span> <span class=o>{</span>
            <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>j</span><span class=o>,</span> <span class=n>j</span><span class=o>-</span><span class=n>1</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>倒置是指数组中两个顺序颠倒的元素, 例如"E A"中E-A就是一对倒置, 如果数组中倒置的数量小于数组大小的某个倍数, 则称该数组为部分有序. 部分有序有以下
几种典型情况:</p><ul><li>数组中每个元素距离它的最终位置都不远.</li><li>一个有序的大数组接一个小数组.</li><li>数组中只有几个元素的位置不正确.</li></ul><p>插入排序对这样的数组很有效, 当倒置数量很少时, 插入排序可能比其他任何排序都快. 事实上, 设长度为N的数组的倒置数量为m, 则插入排序需要的交换操作等于m,
需要的比较次数大于等于m, 小于等于m+N-1.</p><p>对于随机排序的无重复主键的数组, 插入排序和选择排序的运行时间是平方级别的, 两者之比应该是一个较小的常数.</p><h2 id=希尔排序>希尔排序<a hidden class=anchor aria-hidden=true href=#希尔排序>#</a></h2><p>希尔排序简单的改进了插入排序, 其思想是使数组中任意间隔为h的元素都是有序的, 这样的数组称为h有序数组. 一个h有序数组指的是h个互相独立的数组交错在一起
的数组, 当h很大时, 就能把元素移到较远的位置. 对于任意以1结尾的h序列, 数组都能够排序.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span>
    <span class=c1>// 使用序列1/2 (3^k - 1)
</span><span class=c1></span>    <span class=k>while</span> <span class=o>(</span><span class=n>h</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>/</span><span class=n>3</span><span class=o>)</span> <span class=n>h</span> <span class=o>=</span> <span class=n>3</span> <span class=o>*</span> <span class=n>h</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>h</span> <span class=o>&gt;=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>h</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=n>h</span> <span class=o>&amp;&amp;</span> <span class=n>Sort</span><span class=o>.</span><span class=na>less</span><span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>],</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>h</span><span class=o>]);</span> <span class=n>j</span> <span class=o>-=</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>j</span><span class=o>,</span> <span class=n>j</span> <span class=o>-</span> <span class=n>h</span><span class=o>);</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=n>h</span> <span class=o>/=</span> <span class=n>3</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>算法的性能取决于h序列的选择, 我们选择的序列在最坏的情况下与$ N^{3/2} $成正比. 其他算法在N不是特别大的情况下, 大约只比希尔排序快2倍左右.</p><h2 id=归并排序>归并排序<a hidden class=anchor aria-hidden=true href=#归并排序>#</a></h2><p>归并排序保证任意长度为N的数组排序所需的时间和NlgN成正比, 它的主要缺点是所需的额外空间也和N成正比.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 自顶向下
</span><span class=c1></span><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=c1>// 辅助数组
</span><span class=c1></span>    <span class=n>aux</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Comparable</span><span class=o>[</span><span class=n>N</span><span class=o>];</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>N</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>hi</span> <span class=o>&lt;=</span> <span class=n>lo</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=o>(</span><span class=n>hi</span> <span class=o>-</span> <span class=n>lo</span><span class=o>)/</span><span class=n>2</span><span class=o>;</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lo</span><span class=o>,</span> <span class=n>mid</span><span class=o>);</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
    <span class=n>merge</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lo</span><span class=o>,</span> <span class=n>mid</span><span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>merge</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>mid</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>lo</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=o>;</span> <span class=n>k</span><span class=o>++)</span> <span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>];</span>

    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>lo</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=o>;</span> <span class=n>k</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>mid</span><span class=o>)</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++];</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>&gt;</span> <span class=n>hi</span><span class=o>)</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++];</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>Sort</span><span class=o>.</span><span class=na>less</span><span class=o>(</span><span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>],</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>]))</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++];</span>
        <span class=k>else</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++];</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>对于长度为N的数组, 自顶向下的归并排序需要1/2NlgN到NlgN次比较.</p><blockquote><p>证明: 令C(N)表示将一个长度为N的数组排序所需要的比较次数, 我们容易得到$ C(0)=C(1)=0 $, 对于N>1的情况有:
$$ C(N) \le C(\lceil N/2 \rceil) + C(\lfloor N/2 \rfloor) + N $$
以及:
$$ C(N) \ge C(\lceil N/2 \rceil) + C(\lfloor N/2 \rfloor) + N/2 $$
当$ N=2^{n} $时, 有解:
$$ C(2^n)/2^n = C(2^0)/2^0 + n = n $$
两边同时乘以$ 2^n $并代回N,有:
$$ C(N) = C(2^n) = n \times 2^n = NlgN $$</p></blockquote><p>同理, 自顶向下的归并排序最多需要访问数组6NlgN.</p><p>用不同的方法处理小规模问题能改进大多数递归算法的性能, 因为递归会使小规模问题中方法的调用过于频繁, 从而改进对它们的处理方法能够改进整个算法. 在归并
算法中, 使用插入排序来处理小规模的子数组一般能将运行时间缩短10%~15%. 而通过测试数组是否有序可以将任何有序的子数组运行时间变为线性.</p><h2 id=排序算法的复杂度>排序算法的复杂度<a hidden class=anchor aria-hidden=true href=#排序算法的复杂度>#</a></h2><p>我们研究的排序算法是基于比较的(忽略了访问数组的开销), 一个基于比较的算法在两次比较之间可能会进行任意规模的计算, 但它们只能通过主键之间的比较来得到关
于某个主键的信息.</p><p>没有任何基于比较的算法能够保证使用少于~NlgN(lgN!)次比较将长度为N的数组排序.</p><blockquote><p>证明: 假设数组没有重复的主键, 用二叉树来表示所有可能的情况. 那么叶子数最少是N!, 因为对于N个不同的主键有N!种不同的排列, 于是任何基于比较的
排序算法都对应着一颗高为h的二叉树, 其中:
$$ N! \le 叶子数 \le 2^h $$
而算法的复杂度对应与根节点到叶子的路径长, 即 $ T \ge lgN! $, 根据斯特灵公式有lgN! ~NlgN.</p></blockquote><p>上述论证意味着, 没有任何排序算法能够用少于~NlgN次比较将数组排序, 归并排序是一种渐进最优的基于比较排序的算法.
但在实际情况中:</p><ul><li>归并排序的空间复杂度不是最优的.</li><li>在实践中不一定是最坏的情况.</li><li>算法的其他操作也可能成为关键所在.</li><li>不进行比较也能够将某些数组排序.</li></ul><h2 id=快速排序>快速排序<a hidden class=anchor aria-hidden=true href=#快速排序>#</a></h2><p>快速排序的特点包括原地排序(只需要一个很小的辅助栈), 且将长度为N的数组排序的时间和NlgN成正比. 另外, 快速排序的内循环比大多数排序算法都小. 它的主要
缺点在于非常脆弱, 实现时要避免低劣的性能. 快速排序的效率依赖于切分数组的效果, 即依赖于切分数组的值.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>//简单的实现
</span><span class=c1></span><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>StdRandom</span><span class=o>.</span><span class=na>shuffle</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>hi</span> <span class=o>&lt;</span> <span class=n>lo</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>partition</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lo</span><span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lo</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>j</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>partition</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>lo</span> <span class=o>==</span> <span class=n>hi</span><span class=o>)</span> <span class=k>return</span> <span class=n>lo</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>hi</span> <span class=o>+</span> <span class=n>1</span><span class=o>;</span>
    <span class=n>Comparable</span> <span class=n>v</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>lo</span><span class=o>];</span>
    <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>Sort</span><span class=o>.</span><span class=na>less</span><span class=o>(</span><span class=n>a</span><span class=o>[++</span><span class=n>i</span><span class=o>],</span> <span class=n>v</span><span class=o>))</span> <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>hi</span><span class=o>)</span> <span class=k>break</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>Sort</span><span class=o>.</span><span class=na>less</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>a</span><span class=o>[--</span><span class=n>j</span><span class=o>]))</span> <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>==</span> <span class=n>lo</span><span class=o>)</span> <span class=k>break</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>j</span><span class=o>)</span> <span class=k>break</span><span class=o>;</span>
        <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lo</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>j</span><span class=o>;</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>快速排序的最好情况是每次都正好能将数组对半分, 此时满足分治递归的$ C_N = 2C_{N/2} + N $公式, 这样得到的解是NlgN. 平均而言, 切分元素都能够落在
数组的中间.</p><p>将长度为N的无重复数组排序, 快速排序平均需要~2NlgN次比较.</p><blockquote><p>证明: 令$ C_k $为将N个不同元素排序平均需要的比较次数, 显然有$ C_0=C_1=0 $, 对于N>1的情况, 可得到以下递归关系:
$$ C_N = N + 1 + (C_0 + C_1 + \cdots + C_{N-2} + C_{N-1})/N + (C_{N-1} + C_{N-2} + \cdots + C_0)/N $$
其中第一项是切分成本, 总是N+1, 后面两项是左右子数组排序的平均成本, 等式两边同乘以N得到:
$$ NC_N = N(N+1) + 2(C_0 + C_1 + \cdots + C_{N-1}) $$
即:
$$ NC_N - (N-1)C_{N-1} = 2N + 2C_{N-1} $$
进而得到:
$$ C_N/(N+1) = C_{N-1}/N + 2/(N+1) $$
于是有$ C_N/(N+1) - C_1/2 = 2(1/3 + 1/4 + \cdots + 1/(N+1)) $, 即$ C_N = 2(N+1)(1/3 + 1/4 + \cdots + 1/(N+1)) $
近似的得到$ C_N \approx 2NlnN \approx 1.39NlgN $, 即平均的比较次数比最好的情况多39%.</p></blockquote><p>上述简单的快速排序有一个潜在的缺点, 即在切分不平衡时, 可能会极为低效, 在最坏的情况下快速排序需要$ N^2/2 $次比较, 我们在排序前shuffle数组就是为了
减少这种情况的发生.</p><h3 id=改进>改进<a hidden class=anchor aria-hidden=true href=#改进>#</a></h3><ol><li>适时切换到插入排序
和大多数递归算法一样, 对于小数组快速排序比插入排序更慢, 在数组长度为5~15之间选择插入排序通常能取得较好的效果.</li><li>三取样切分
使用子数组的一小部分元素的中位数来切分数组, 这样能得到更好的切分, 但需要额外计算中位数的代价, 当取样大小为3时切分效果最好, 还可以放置哨兵来取消
边界检测.</li><li>熵最优排序
当数组中含有大量重复元素的时候, 对于元素全部重复的元素可以不再排序. 一个简单的办法是将数组切分为三部分(荷兰国旗问题).</li></ol><h3 id=三向切分的快速排序>三向切分的快速排序<a hidden class=anchor aria-hidden=true href=#三向切分的快速排序>#</a></h3><p>E. W. Dijkstra提出的三向切分解法:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>StdRandom</span><span class=o>.</span><span class=na>shuffle</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>0</span><span class=o>,</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
<span class=o>}</span>

<span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>hi</span> <span class=o>&lt;=</span> <span class=n>lo</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>lt</span> <span class=o>=</span> <span class=n>lo</span><span class=o>,</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>gt</span> <span class=o>=</span> <span class=n>hi</span><span class=o>;</span>
    <span class=n>Comparable</span> <span class=n>v</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>lo</span><span class=o>];</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>gt</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>cmp</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>i</span><span class=o>].</span><span class=na>compareTo</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cmp</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>)</span> <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lt</span><span class=o>++,</span> <span class=n>i</span><span class=o>++);</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>cmp</span> <span class=o>&gt;</span> <span class=n>0</span><span class=o>)</span> <span class=n>Sort</span><span class=o>.</span><span class=na>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>gt</span><span class=o>--,</span> <span class=n>i</span><span class=o>);</span>
        <span class=k>else</span> <span class=n>i</span><span class=o>++;</span>
    <span class=o>}</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>lo</span><span class=o>,</span> <span class=n>lt</span> <span class=o>-</span> <span class=n>1</span><span class=o>);</span>
    <span class=n>sort</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>gt</span> <span class=o>+</span> <span class=n>1</span><span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>对于只有若干不同主键的随机数组, 三向切分快速排序能够达到线性级别. 给定包含k个不同值的N个主键, 定义$ f_i $为第i个主键出现的次数, $ p_i = f_i/N $
即第i个主键出现的概率, 那么香农熵定义为:
$$ H = -(p_1lgp_1 + p_2lgp_2 + \cdots + p_klgp_k) $$
可以得到:</p><ul><li>不存在任何基于比较的算法能够保证在NH-N次比较内将N个元素排序.</li><li>对于大小为N的数组, 三向切分的快速排序需要~(2ln2)NH次比较.</li></ul><p>当不存在重复主键时, $ H=lgN $, 而有重复主键时, 其具有更好的性能. 这两个性质说明了三向切分的快速排序是信息最优的.</p><h2 id=堆排序>堆排序<a hidden class=anchor aria-hidden=true href=#堆排序>#</a></h2><p>堆排序首先构造一个堆, 然后使用下沉操作将数组按升序排序.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>N</span> <span class=o>/</span> <span class=n>2</span><span class=o>;</span> <span class=n>k</span> <span class=o>&gt;=</span> <span class=n>1</span><span class=o>;</span> <span class=n>k</span><span class=o>--)</span> <span class=n>sink</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>k</span><span class=o>,</span> <span class=n>N</span><span class=o>);</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>N</span> <span class=o>&gt;</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>1</span><span class=o>,</span> <span class=n>N</span><span class=o>--);</span>
        <span class=n>sink</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>1</span><span class=o>,</span> <span class=n>N</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>boolean</span> <span class=nf>less</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>a</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>1</span><span class=o>].</span><span class=na>compareTo</span><span class=o>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>1</span><span class=o>])</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>exch</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Comparable</span> <span class=n>t</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>1</span><span class=o>];</span>
    <span class=n>a</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>1</span><span class=o>]</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>1</span><span class=o>];</span>
    <span class=n>a</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>1</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sink</span><span class=o>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>,</span> <span class=kt>int</span> <span class=n>N</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>2</span> <span class=o>*</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>N</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>2</span> <span class=o>*</span> <span class=n>k</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span> <span class=o>&amp;&amp;</span> <span class=n>less</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>j</span><span class=o>,</span> <span class=n>j</span> <span class=o>+</span> <span class=n>1</span><span class=o>))</span> <span class=n>j</span><span class=o>++;</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>less</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>k</span><span class=o>,</span> <span class=n>j</span><span class=o>))</span> <span class=k>break</span><span class=o>;</span>
        <span class=n>exch</span><span class=o>(</span><span class=n>a</span><span class=o>,</span> <span class=n>k</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
        <span class=n>k</span> <span class=o>=</span> <span class=n>j</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>将N个元素排序, 堆排序需要(2NlgN+2N)次比较(2N来源于堆的构造). 堆排序在排序复杂性的研究中具有重要地位, 因为它是唯一一个能够同时最优地利用空间和时间
的方法, 在最坏的情况下它也能保证~2NlgN次比较和恒定的空间. 在空间紧张的场景下具有很好的效果, 但却很少被现代操作系统的其他应用采用, 因为其无法利用缓
存.</p><h2 id=常用排序算法的比较>常用排序算法的比较<a hidden class=anchor aria-hidden=true href=#常用排序算法的比较>#</a></h2><table><thead><tr><th style=text-align:center>算法</th><th style=text-align:center>稳定性</th><th style=text-align:center>原地</th><th style=text-align:center>时间复杂度</th><th style=text-align:center>空间复杂度</th></tr></thead><tbody><tr><td style=text-align:center>选择排序</td><td style=text-align:center>否</td><td style=text-align:center>是</td><td style=text-align:center>$ N^2 $</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>插入排序</td><td style=text-align:center>是</td><td style=text-align:center>是</td><td style=text-align:center>N到$ N^2 $</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>希尔排序</td><td style=text-align:center>否</td><td style=text-align:center>是</td><td style=text-align:center>$ N^{3/2} $</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center>快速排序</td><td style=text-align:center>否</td><td style=text-align:center>是</td><td style=text-align:center>NlgN</td><td style=text-align:center>lgN</td></tr><tr><td style=text-align:center>三向快速排序</td><td style=text-align:center>否</td><td style=text-align:center>是</td><td style=text-align:center>N到lgN</td><td style=text-align:center>lgN</td></tr><tr><td style=text-align:center>归并排序</td><td style=text-align:center>是</td><td style=text-align:center>否</td><td style=text-align:center>NlgN</td><td style=text-align:center>N</td></tr><tr><td style=text-align:center>堆排序</td><td style=text-align:center>否</td><td style=text-align:center>是</td><td style=text-align:center>NlgN</td><td style=text-align:center>1</td></tr></tbody></table><p>大多数情况下快速排序是最佳选择; 如果需要稳定性且空间充足的情况下, 归并排序是很好的选择; 对于原始的数据, 直接操作数据排序更合适.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://christophe1997.github.io/tags/java>Java</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 排序算法 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f&hashtags=Java"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 排序算法 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95&summary=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95&source=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 排序算法 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f&title=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 排序算法 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 排序算法 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%20-%20https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 排序算法 on telegram" href="https://telegram.me/share/url?text=%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fsorting-algorithms%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://christophe1997.github.io>CastOff</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});"></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>