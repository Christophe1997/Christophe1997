<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Object Lifetime and Storage Management | CastOff</title><meta name=keywords content="内存分配"><meta name=description content="在考虑标识符和绑定(bindings)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:
 对象的创建 绑定的创建 所有使用绑定的情况, 诸如引用变量, 子程序, 类型等 停用和重用那些暂时没有用的绑定 绑定的析构(destruction) 对象的析构  绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当 标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的&参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期, 虽然这通常被认为是一个BUG.
对象的生命周期通常与以下内存分配(storage allocation)机制有关:
 静态(static)对象会在程序的整个运行过程中被分配一个绝对地址. 栈(stack)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构. 堆(heap)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.  静态分配(static allocation) 静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配 的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值 不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.
在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被 叫做表现常量(manifest constants)或者编译期常量(compile-time constants). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了 声明两种常量的方法, 即const和readonly关键字.
另外编译器通常对于子程序的某些值采用特定的分配策略:
 参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中. 临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内. bookkeeping information, 这些通常包含子程序的返回地址."><meta name=author content="Christophe"><link rel=canonical href=https://christophe1997.github.io/posts/2018/object-lifetime-and-storage-management/><meta name=google-site-verification content="CastOff"><link href=https://christophe1997.github.io/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet" as=style><link rel=icon href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-112755173-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Object Lifetime and Storage Management"><meta property="og:description" content="在考虑标识符和绑定(bindings)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:
 对象的创建 绑定的创建 所有使用绑定的情况, 诸如引用变量, 子程序, 类型等 停用和重用那些暂时没有用的绑定 绑定的析构(destruction) 对象的析构  绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当 标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的&参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期, 虽然这通常被认为是一个BUG.
对象的生命周期通常与以下内存分配(storage allocation)机制有关:
 静态(static)对象会在程序的整个运行过程中被分配一个绝对地址. 栈(stack)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构. 堆(heap)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.  静态分配(static allocation) 静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配 的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值 不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.
在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被 叫做表现常量(manifest constants)或者编译期常量(compile-time constants). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了 声明两种常量的方法, 即const和readonly关键字.
另外编译器通常对于子程序的某些值采用特定的分配策略:
 参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中. 临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内. bookkeeping information, 这些通常包含子程序的返回地址."><meta property="og:type" content="article"><meta property="og:url" content="https://christophe1997.github.io/posts/2018/object-lifetime-and-storage-management/"><meta property="article:published_time" content="2018-12-08T16:48:49+00:00"><meta property="article:modified_time" content="2018-12-08T16:48:49+00:00"><meta property="og:site_name" content="CastOff"><meta name=twitter:card content="summary"><meta name=twitter:title content="Object Lifetime and Storage Management"><meta name=twitter:description content="在考虑标识符和绑定(bindings)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:
 对象的创建 绑定的创建 所有使用绑定的情况, 诸如引用变量, 子程序, 类型等 停用和重用那些暂时没有用的绑定 绑定的析构(destruction) 对象的析构  绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当 标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的&参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期, 虽然这通常被认为是一个BUG.
对象的生命周期通常与以下内存分配(storage allocation)机制有关:
 静态(static)对象会在程序的整个运行过程中被分配一个绝对地址. 栈(stack)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构. 堆(heap)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.  静态分配(static allocation) 静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配 的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值 不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.
在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被 叫做表现常量(manifest constants)或者编译期常量(compile-time constants). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了 声明两种常量的方法, 即const和readonly关键字.
另外编译器通常对于子程序的某些值采用特定的分配策略:
 参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中. 临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内. bookkeeping information, 这些通常包含子程序的返回地址."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Object Lifetime and Storage Management","name":"Object Lifetime and Storage Management","description":"在考虑标识符和绑定(bindings)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:\n 对象的创建 绑定的创建 所有使用绑定的情况, 诸如引用变量, 子程序, 类型等 停用和重用那些暂时没有用的绑定 绑定的析构(destruction) 对象的析构  绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常 …","keywords":["内存分配"],"articleBody":"在考虑标识符和绑定(bindings)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:\n 对象的创建 绑定的创建 所有使用绑定的情况, 诸如引用变量, 子程序, 类型等 停用和重用那些暂时没有用的绑定 绑定的析构(destruction) 对象的析构  绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当 标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的\u0026参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期, 虽然这通常被认为是一个BUG.\n对象的生命周期通常与以下内存分配(storage allocation)机制有关:\n 静态(static)对象会在程序的整个运行过程中被分配一个绝对地址. 栈(stack)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构. 堆(heap)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.  静态分配(static allocation) 静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配 的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值 不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.\n在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被 叫做表现常量(manifest constants)或者编译期常量(compile-time constants). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了 声明两种常量的方法, 即const和readonly关键字.\n另外编译器通常对于子程序的某些值采用特定的分配策略:\n 参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中. 临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内. bookkeeping information, 这些通常包含子程序的返回地址.  基于栈的分配(stack-based allocation) 一门语言如果想要支持递归, 那么在局部变量上采用静态分配的策略将不再适用(Fortran90之前不支持递归), 因为需要变量的个数是未知的. 所幸的是递归天然地适用 于栈结构的分配策略. 每一个子程序在运行时都有一个栈帧(frame, 或者称为活动记录, activation record), 包含了传入参数, 局部变量, 临时变量, 以及 bookkeeping信息. 通常传入参数位于帧的顶部, 方便被调用者定位参数, 而其他的布局则依赖于实现. 栈的维护是子程序调用序列的责任, 即调用者在调用前(序言, prologue)和调用后(尾声, epilogue)执行的代码. 通常有一个帧指针(frame pointer)来保存当前帧的地址, 在大多数语言的实现中, 栈都是往地址减 小的方向增长的. 在这样的实现方式下, 局部变量, 临时变量, bookkeeping信息对于帧指针有一个负的偏移, 而传入参数和返回对于帧指针则有一个正的偏移, 因为 这些都保存在调用者的帧上.\n即时没有递归的语言也可以从基于栈的分配中获益, 因为大多数语言的子程序都无法在同一个时间内运行, 如果采用静态分配意味着需要预先分配所有局部变量(运行的与 不运行的), 而基于栈的分配则可以节省很大的空间开销.\n基于堆的分配(heap-based allocation) 堆上的子块(subblock)可以在任何时候分配和释放. 堆对于那些链式数据结构, 以及在运行时会改变大小的对象, 诸如列表, 集合, 通用的字符串等是必须的. 堆上的空间管理策略众多, 主要的原则是在速度和空间上进行权衡. 空间上又可以细分为内部错误(internal fragmentation)与外部错误(external fragmentation), 内部错误发生在一个内存分配算法分配的块比实际对象需要的空间更大, 而外部错误发生在未被使用的空间过于碎片化, 虽然有空间但无法满足实际 对象的需要. 许多内存管理算法都管理一个单链表, 即有堆内未被使用的块组成的可用链表(free list), 初始状态下这个链表只包含一个块即整个堆. first fit 算法会选择满足要求的第一个块, best fit 算法则会遍历整个链表寻找最小的且满足要求的块. 无论采用哪种策略, 如果被选择的块大小比实际需要的更大, 会将块分 成两部分, 返回满足要求的部分而将剩下的部分放回可用链表(如果剩余部分比最小的限制更小的话, 则会产生一个内部错误即不放回而返回一个更大的块). 当某个块 被释放而返回可用链表时, 将检查地址上与其相邻的一边或两边是否也有空闲的块, 如果有的话则将其合并. 直观上来讲, 希望能够有一个的 best fit 的算法能够 尽可能的将更大的块分给更大的对象. 与此同时, 该算法将花费更多的时间, 因为其必须遍历以寻找最合适的块. 并且该算法更倾向于产生更多的碎片. first fit 与 best fit 哪一种能够产生更少的外部错误取决于要求分配大小的分布.\n在管理单个链表的内存算法中, 分配空间所花费的时间与可用块的数量成正比. 为了将这个开销降到常数级, 一些内存管理算法管理包含不同大小的多条链表, 每一个分 配请求都会选择一个合适的标准大小的链表. 实际上, 堆被划分为许多池(pools), 每一个对应一个标准大小, 且划分可以是静态的也可以是动态的. 两种广泛使用 的动态池调整机制包括伙伴系统(buddy system)和斐波那契堆(Fibonacci heap). 在伙伴系统中, 标准大小是2的幂次方序列, 如果请求一个大小为 $2^k$ 的块但不满足时会将一个大小为 $2^{k+1}$的块平分, 其中一个返回而将剩下的放入第k条链表中(标准大小为$2^k$). 当块被释放时, 其将于其可用的\"伙伴\"(平分 时出现的另一半)合并. 类似的, 斐波那契堆将标准大小序列分成斐波那契数列, 该算法产生内部错误比伙伴系统更少, 因为斐波那契数列增长比2的指数序列更为缓慢.\n外部错误出现的问题在于堆的分配能力总是随着时间下降的. 总存在一个分配序列使得总大小小于堆的大小而堆无法完成所有分配, 为了减少外部错误, 必须要压紧(compact) 堆.\n垃圾回收(garbage collection) 使用堆分配的对象, 在某些语言中(C, C++, Pascal)可以显示释放, 而更多的语言则规定分配的对象将在不再被使用时隐式地释放. 对于这种语言的运行时库(run-time library)必须要提供垃圾回收(garbage collection)机制来识别和回收不可达的对象. 许多函数式语言和脚本语言以及最近的命令式(imprerative, 指广泛意义上的)语言, 如Java, Modula-3和C#都提供了垃圾回收. 支持显示释放的传统观点包括实现更简单以及执行更高效, 即使是一个简单(naive)的自动垃圾 收集对于一个类型系统丰富的语言来说也会增加不小的复杂度, 另外即时是一个复杂的(sophisticated)的垃圾收集器也需要一个非常数的开销. 因此, 如果程序员 能够正确的界定一个对象的生命周期, 那么就不需要额外的运行时负担且能达到更高的效率. 而支持自动垃圾收集的观点则更为引人注目(compelling): 人为的释放 错误在现实世界中广泛存在并常常导致BUG, 如果一个对象释放的太早则会导致一个悬挂引用(dangling reference), 访问一个被另外对象所使用的空间; 相反 如果释放的过迟则可能会导致内存泄露问题, 最终甚至耗尽堆内存. 臭名昭著的释放内存错误难以定位和修复, 随着前沿程序的复杂性以及体积与日俱增, 能够从自动垃圾 收集中收获更大的益处.\n","wordCount":"229","inLanguage":"en","datePublished":"2018-12-08T16:48:49Z","dateModified":"2018-12-08T16:48:49Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://christophe1997.github.io/posts/2018/object-lifetime-and-storage-management/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://christophe1997.github.io accesskey=h>CastOff</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://christophe1997.github.io/tags/><span>Tags</span></a></li><li><a href=https://christophe1997.github.io/categories/><span>Categories</span></a></li><li><a href=https://christophe1997.github.io/archives/><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Object Lifetime and Storage Management</h1><div class=post-meta>December 8, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><p>在考虑标识符和绑定(<em>bindings</em>)的时候, 关键在于区分标识符和它们所引用的对象, 以及以下事件:</p><ol><li>对象的创建</li><li>绑定的创建</li><li>所有使用绑定的情况, 诸如引用变量, 子程序, 类型等</li><li>停用和重用那些暂时没有用的绑定</li><li>绑定的析构(<em>destruction</em>)</li><li>对象的析构</li></ol><p>绑定的生命周期指的是这个绑定从创建到析构的整个过程, 类似的可以定义对象的生命周期. 通常情况下, 一个对象的生命周期可能会大于对应的绑定的生命周期, 即当
标识符不再引用该对象时, 该对象依然存在(例如在子程序中传入某个对象的引用, 如C++中的<code>&</code>参数). 当然, 一个绑定的生命周期也有可能大于对应对象的生命周期,
虽然这通常被认为是一个BUG.</p><p>对象的生命周期通常与以下内存分配(<em>storage allocation</em>)机制有关:</p><ol><li>静态(<em>static</em>)对象会在程序的整个运行过程中被分配一个绝对地址.</li><li>栈(<em>stack</em>)对象随着子程序的调用和返回而被创建以及按照LIFO的顺序析构.</li><li>堆(<em>heap</em>)对象可以在任何时候创建和析构, 其额外要求更加通用和昂贵的内存分配算法.</li></ol><h2 id=静态分配_static-allocation_>静态分配(<em>static allocation</em>)<a hidden class=anchor aria-hidden=true href=#静态分配_static-allocation_>#</a></h2><p>静态分配最明显的例子就是全局对象, 当然全局对象不是唯一的例子. 构成程序机器语言翻译的指令也可以认为是静态分配的变量; 数字和字符串的常量当然也是静态分配
的; 另外很多编译器会产生一系列的表用于支持运行时的debug, 动态类型检查, 垃圾回收, 异常处理等, 这些表也都是静态分配的. 静态分配的对象通常希望它们的值
不在变化, 因此经常被分配在被保护的只读的内存中以方便在试图修改其值产生中断并抛出运行时错误.</p><p>在很多语言中,一个具名常量通常要求有一个能够在编译期确定的初始值. 通常这些初始值都被限制在那些已知的常量以及内置的函数. 这些具名常量加上字面常量通常被
叫做表现常量(<em>manifest constants</em>)或者编译期常量(<em>compile-time constants</em>). 在某些语言中(C, Ada), 常量仅仅只是那些无法在elaboration
time之后改变的值, 这些值可能依赖与其他在运行时才能确定的值. 这些elaboration-time的常量在作为递归函数的局部变量时必须要分配在栈上. C#显示提供了
声明两种常量的方法, 即<code>const</code>和<code>readonly</code>关键字.</p><p>另外编译器通常对于子程序的某些值采用特定的分配策略:</p><ol><li>参数和返回值, 编译器通常会尽可能的将这些值存在寄存器中.</li><li>临时变量, 通常是那些复杂计算过程的中间值, 一个优秀的编译器也会将它们保存在寄存器内.</li><li><em>bookkeeping information</em>, 这些通常包含子程序的返回地址.</li></ol><h2 id=基于栈的分配_stack-based-allocation_>基于栈的分配(<em>stack-based allocation</em>)<a hidden class=anchor aria-hidden=true href=#基于栈的分配_stack-based-allocation_>#</a></h2><p>一门语言如果想要支持递归, 那么在局部变量上采用静态分配的策略将不再适用(Fortran90之前不支持递归), 因为需要变量的个数是未知的. 所幸的是递归天然地适用
于栈结构的分配策略. 每一个子程序在运行时都有一个栈帧(<em>frame</em>, 或者称为活动记录, <em>activation record</em>), 包含了传入参数, 局部变量, 临时变量, 以及
bookkeeping信息. 通常传入参数位于帧的顶部, 方便被调用者定位参数, 而其他的布局则依赖于实现. 栈的维护是子程序调用序列的责任, 即调用者在调用前(序言,
<em>prologue</em>)和调用后(尾声, <em>epilogue</em>)执行的代码. 通常有一个帧指针(<em>frame pointer</em>)来保存当前帧的地址, 在大多数语言的实现中, 栈都是往地址减
小的方向增长的. 在这样的实现方式下, 局部变量, 临时变量, bookkeeping信息对于帧指针有一个负的偏移, 而传入参数和返回对于帧指针则有一个正的偏移, 因为
这些都保存在调用者的帧上.</p><p>即时没有递归的语言也可以从基于栈的分配中获益, 因为大多数语言的子程序都无法在同一个时间内运行, 如果采用静态分配意味着需要预先分配所有局部变量(运行的与
不运行的), 而基于栈的分配则可以节省很大的空间开销.</p><h2 id=基于堆的分配_heap-based-allocation_>基于堆的分配(<em>heap-based allocation</em>)<a hidden class=anchor aria-hidden=true href=#基于堆的分配_heap-based-allocation_>#</a></h2><p>堆上的子块(<em>subblock</em>)可以在任何时候分配和释放. 堆对于那些链式数据结构, 以及在运行时会改变大小的对象, 诸如列表, 集合, 通用的字符串等是必须的.
堆上的空间管理策略众多, 主要的原则是在速度和空间上进行权衡. 空间上又可以细分为内部错误(<em>internal fragmentation</em>)与外部错误(<em>external
fragmentation</em>), 内部错误发生在一个内存分配算法分配的块比实际对象需要的空间更大, 而外部错误发生在未被使用的空间过于碎片化, 虽然有空间但无法满足实际
对象的需要. 许多内存管理算法都管理一个单链表, 即有堆内未被使用的块组成的可用链表(<em>free list</em>), 初始状态下这个链表只包含一个块即整个堆. <em>first fit</em>
算法会选择满足要求的第一个块, <em>best fit</em> 算法则会遍历整个链表寻找最小的且满足要求的块. 无论采用哪种策略, 如果被选择的块大小比实际需要的更大, 会将块分
成两部分, 返回满足要求的部分而将剩下的部分放回可用链表(如果剩余部分比最小的限制更小的话, 则会产生一个内部错误即不放回而返回一个更大的块). 当某个块
被释放而返回可用链表时, 将检查地址上与其相邻的一边或两边是否也有空闲的块, 如果有的话则将其合并. 直观上来讲, 希望能够有一个的 <em>best fit</em> 的算法能够
尽可能的将更大的块分给更大的对象. 与此同时, 该算法将花费更多的时间, 因为其必须遍历以寻找最合适的块. 并且该算法更倾向于产生更多的碎片. <em>first fit</em>
与 <em>best fit</em> 哪一种能够产生更少的外部错误取决于要求分配大小的分布.</p><p>在管理单个链表的内存算法中, 分配空间所花费的时间与可用块的数量成正比. 为了将这个开销降到常数级, 一些内存管理算法管理包含不同大小的多条链表, 每一个分
配请求都会选择一个合适的标准大小的链表. 实际上, 堆被划分为许多池(<em>pools</em>), 每一个对应一个标准大小, 且划分可以是静态的也可以是动态的. 两种广泛使用
的动态池调整机制包括伙伴系统(<em>buddy system</em>)和斐波那契堆(<em>Fibonacci heap</em>). 在伙伴系统中, 标准大小是2的幂次方序列, 如果请求一个大小为 $2^k$
的块但不满足时会将一个大小为 $2^{k+1}$的块平分, 其中一个返回而将剩下的放入第k条链表中(标准大小为$2^k$). 当块被释放时, 其将于其可用的"伙伴"(平分
时出现的另一半)合并. 类似的, 斐波那契堆将标准大小序列分成斐波那契数列, 该算法产生内部错误比伙伴系统更少, 因为斐波那契数列增长比2的指数序列更为缓慢.</p><p>外部错误出现的问题在于堆的分配能力总是随着时间下降的. 总存在一个分配序列使得总大小小于堆的大小而堆无法完成所有分配, 为了减少外部错误, 必须要压紧(<em>compact</em>)
堆.</p><h2 id=垃圾回收_garbage-collection_>垃圾回收(<em>garbage collection</em>)<a hidden class=anchor aria-hidden=true href=#垃圾回收_garbage-collection_>#</a></h2><p>使用堆分配的对象, 在某些语言中(C, C++, Pascal)可以显示释放, 而更多的语言则规定分配的对象将在不再被使用时隐式地释放. 对于这种语言的运行时库(<em>run-time
library</em>)必须要提供垃圾回收(<em>garbage collection</em>)机制来识别和回收不可达的对象. 许多函数式语言和脚本语言以及最近的命令式(<em>imprerative</em>,
指广泛意义上的)语言, 如Java, Modula-3和C#都提供了垃圾回收. 支持显示释放的传统观点包括实现更简单以及执行更高效, 即使是一个简单(<em>naive</em>)的自动垃圾
收集对于一个类型系统丰富的语言来说也会增加不小的复杂度, 另外即时是一个复杂的(<em>sophisticated</em>)的垃圾收集器也需要一个非常数的开销. 因此, 如果程序员
能够正确的界定一个对象的生命周期, 那么就不需要额外的运行时负担且能达到更高的效率. 而支持自动垃圾收集的观点则更为引人注目(<em>compelling</em>): 人为的释放
错误在现实世界中广泛存在并常常导致BUG, 如果一个对象释放的太早则会导致一个悬挂引用(<em>dangling reference</em>), 访问一个被另外对象所使用的空间; 相反
如果释放的过迟则可能会导致内存泄露问题, 最终甚至耗尽堆内存. 臭名昭著的释放内存错误难以定位和修复, 随着前沿程序的复杂性以及体积与日俱增, 能够从自动垃圾
收集中收获更大的益处.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://christophe1997.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D>内存分配</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Object Lifetime and Storage Management on twitter" href="https://twitter.com/intent/tweet/?text=Object%20Lifetime%20and%20Storage%20Management&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f&hashtags=%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Object Lifetime and Storage Management on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f&title=Object%20Lifetime%20and%20Storage%20Management&summary=Object%20Lifetime%20and%20Storage%20Management&source=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Object Lifetime and Storage Management on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f&title=Object%20Lifetime%20and%20Storage%20Management"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Object Lifetime and Storage Management on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Object Lifetime and Storage Management on whatsapp" href="https://api.whatsapp.com/send?text=Object%20Lifetime%20and%20Storage%20Management%20-%20https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Object Lifetime and Storage Management on telegram" href="https://telegram.me/share/url?text=Object%20Lifetime%20and%20Storage%20Management&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2f2018%2fobject-lifetime-and-storage-management%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://christophe1997.github.io>CastOff</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});"></script><script defer src=https://christophe1997.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>