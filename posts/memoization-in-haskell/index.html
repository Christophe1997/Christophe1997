<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-112755173-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  Memoization in Haskell &ndash; CastOff

    </title>
    
    
    <meta name="description" property="og:description" content="Memoization是动态规划(Dynamic Programming)中自顶向下处理问题采用的策略, 其基本想法是通过将子问题的解保存起来避|">
    

    <meta name="apple-mobile-web-app-title" content="CastOff">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    

    <meta name="msvalidate.01" content="A66009ECF32987EBBB7783F428A03342" />
    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://christophe1997.github.io">
    CastOff
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item " href="/posts/">
      
      <span>Blogs</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item " href="/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">Memoization in Haskell</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/optimization' class="muted-link">
  <span class="Label Label--gray-darker">Optimization</span>
</a>



<a href='/tags/haskell' class="muted-link">
  <span class="Label Label--gray">Haskell</span>
</a>

<a href='/tags/memoization' class="muted-link">
  <span class="Label Label--gray">Memoization</span>
</a>

<a href='/tags/dp' class="muted-link">
  <span class="Label Label--gray">DP</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2020-11-12. Published at: 2020-06-19.">
        
          Lastmod: 2020-11-12
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>Memoization是动态规划(<em>Dynamic Programming</em>)中自顶向下处理问题采用的策略, 其基本想法是通过将子问题的解保存起来避免重复计算来优化算法. 这个概念本身很简单, 在其他有明显mutable语义的语言中, 实现起来也非常简单. 但是在Haskell中问题就变的复杂了不少, 对于一个原始的函数<code>f :: a -&gt; b</code>你如果要用ref, 比如说IORef, 你必须要把它放到IO monad中, 你的memoize函数就变成了<code>... -&gt; IO (a -&gt; b)</code>. 我们希望是能够找到一个<code>memoize :: ... -&gt; (a -&gt; b)</code>, 这样memoize之后得到的和原函数类型是一致的. 为了讨论的方便, 我们主要关注两个例子的memoization, 一个是经典的Fibonacci数列:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>另一个则是动态规划(自底向上)中典型的最小编辑距离的问题, 所谓的最小编辑距离就是一个字符串通过增加, 删除, 替换的操作得到另一个字符串所需要的操作次数:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">minEditDist</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">minEditDist</span> <span class="kt">[]</span>     <span class="kt">[]</span>     <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">minEditDist</span> <span class="n">s</span>      <span class="kt">[]</span>     <span class="ow">=</span> <span class="n">length</span> <span class="n">s</span>
<span class="nf">minEditDist</span> <span class="kt">[]</span>     <span class="n">s</span>      <span class="ow">=</span> <span class="n">length</span> <span class="n">s</span>
<span class="nf">minEditDist</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="ow">=</span> <span class="n">minEditDist</span> <span class="n">xs</span> <span class="n">ys</span>
                           <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">minimum</span> <span class="p">[</span><span class="n">minEditDist</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">,</span> <span class="n">minEditDist</span> <span class="n">xs</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">),</span> <span class="n">minEditDist</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">ys</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="memoizing-with-specific-problem">Memoizing with specific problem</h3>
<p>首先来看<code>fib</code>的问题, <a href="https://wiki.haskell.org/Memoization">wiki</a>给出了一个非常elegant的解(就<code>fib</code>本身而言, 还有更经典的解, <code>fib = (fibs !!) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)</code>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Function</span> <span class="p">(</span><span class="nf">fix</span><span class="p">)</span>

<span class="nf">memoize</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">memoize</span> <span class="n">f</span> <span class="ow">=</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span><span class="p">)</span>

<span class="nf">fib</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fib</span> <span class="n">f</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="n">f</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="n">f</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="nf">fibMemo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">fibMemo</span> <span class="ow">=</span> <span class="n">fix</span> <span class="p">(</span><span class="n">memoize</span> <span class="o">.</span> <span class="n">fib</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然这个<code>memoize</code>和我们想要的<code>(a -&gt; b) -&gt; a -&gt; b</code>有点差距, 但仍然值得分析一下. 首先来看<code>fix</code>, <code>fix</code>的定义很简单:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fix</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">fix</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">x</span>
</code></pre></td></tr></table>
</div>
</div><p>关于<code>fix</code>的详细解释这里略去, 简单而言, 可以将<code>fix</code>理解为一个构建递归的函数. 例如, <code>fix (1:)</code>按定义展开后就是<code>1:(1:(1:(...)))</code>, 很容易看到是一个元素为1的无限列表. 这里的<code>fibMemo = fix (memoize . fib)</code>同样我们按定义展开:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fibMemo</span> <span class="ow">=</span> <span class="n">fix</span> <span class="p">(</span><span class="n">memoize</span> <span class="o">.</span> <span class="n">fib</span><span class="p">)</span>
        <span class="c1">-- fix定义</span>
        <span class="ow">=</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">memoize</span> <span class="o">.</span> <span class="n">fib</span><span class="p">)</span> <span class="n">x</span> <span class="kr">in</span> <span class="n">x</span>
        <span class="ow">=</span> <span class="p">(</span><span class="n">memoize</span> <span class="o">.</span> <span class="n">fib</span><span class="p">)</span> <span class="n">fibMemo</span>
        <span class="ow">=</span> <span class="n">memoize</span> <span class="p">(</span><span class="n">fib</span> <span class="n">fibMemo</span><span class="p">)</span>
        <span class="c1">-- memoize定义</span>
        <span class="ow">=</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">fib</span> <span class="n">fibMemo</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span><span class="p">)</span>

<span class="c1">-- 等价于</span>
<span class="nf">fibMemo</span> <span class="ow">=</span> <span class="p">(</span><span class="n">map</span> <span class="n">fib</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
  <span class="n">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
  <span class="n">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fibMemo</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibMemo</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这种memoization实现利用了Haskell的laziness, <code>fibMemo</code>变成了从一个无限的列表里面取值, 我们已经构建好了每一个元素的表达式, 在需要的时候计算, 这样那些已经计算过的元素就保存在列表里面. 更详细的讲, 我们在定义完fibMemo时其结构为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fibMemo</span> <span class="ow">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">fibMemo</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">fibMemo</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">fibMemo</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">fibMemo</span> <span class="mi">2</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在调用<code>fibMemo 3</code>之后其结构变为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fibMemo</span> <span class="ow">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fib</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">fib</span> <span class="mi">3</span><span class="o">..</span><span class="p">]</span> <span class="o">!!</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到<code>fibMemo 2</code>的结果已经被保存了, 这就实现了memoization.</p>
<p>我们再来看最小编辑距离的问题, 我们显然没法把fib中的<code>memoize</code>直接拿过来. 因为在这个问题上, 我们希望保存的是任意两个子串的最小编辑距离, 从之前fib的memoization借鉴, 开始我们的第一次尝试:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">minEditDistMemo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">minEditDistMemo</span> <span class="n">s1</span> <span class="n">s2</span> <span class="ow">=</span> <span class="n">lookupS</span> <span class="n">s1</span> <span class="n">s2</span>
  <span class="kr">where</span> <span class="n">lookupS</span> <span class="n">x1</span> <span class="n">x2</span> <span class="ow">=</span> <span class="n">maybe</span> <span class="n">undefined</span> <span class="n">id</span> <span class="o">$</span> <span class="n">lookup</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="n">ds</span>
        <span class="n">ds</span>            <span class="ow">=</span> <span class="n">map</span> <span class="n">g</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">x1</span> <span class="ow">&lt;-</span> <span class="n">tails</span> <span class="n">s1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">&lt;-</span> <span class="n">tails</span> <span class="n">s2</span><span class="p">]</span>
        <span class="n">g</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>    <span class="ow">=</span> <span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">),</span> <span class="n">f</span> <span class="n">s1</span> <span class="n">s2</span><span class="p">)</span>
        <span class="n">f</span> <span class="kt">[]</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="mi">0</span>
        <span class="n">f</span> <span class="n">s</span> <span class="kt">[]</span>        <span class="ow">=</span> <span class="n">length</span> <span class="n">s</span>
        <span class="n">f</span> <span class="kt">[]</span> <span class="n">s</span>        <span class="ow">=</span> <span class="n">length</span> <span class="n">s</span>
        <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="ow">=</span> <span class="n">minEditDistMemo</span> <span class="n">xs</span> <span class="n">ys</span>
                        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">minimum</span> <span class="p">[</span><span class="n">minEditDistMemo</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">,</span> <span class="n">minEditDistMemo</span> <span class="n">xs</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">),</span> <span class="n">minEditDistMemo</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">ys</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到, 每次递归调用<code>minEditDistMemo</code>, 它都会构建一个新的ds, 而这是有问题的. 当然这也很容易解决, 只要把每次递归调用<code>minEditDistMemo</code>的地方换成<code>lookupS</code>就行:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">minEditDistMemo</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">minEditDistMemo</span> <span class="n">s1</span> <span class="n">s2</span> <span class="ow">=</span> <span class="n">lookupS</span> <span class="n">s1</span> <span class="n">s2</span>
  <span class="kr">where</span> <span class="n">lookupS</span> <span class="n">x1</span> <span class="n">x2</span> <span class="ow">=</span> <span class="n">maybe</span> <span class="n">undefined</span> <span class="n">id</span> <span class="o">$</span> <span class="n">lookup</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="n">ds</span>
        <span class="n">ds</span>            <span class="ow">=</span> <span class="n">map</span> <span class="n">g</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">x1</span> <span class="ow">&lt;-</span> <span class="n">tails</span> <span class="n">s1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">&lt;-</span> <span class="n">tails</span> <span class="n">s2</span><span class="p">]</span>
        <span class="n">g</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>    <span class="ow">=</span> <span class="p">((</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">),</span> <span class="n">f</span> <span class="n">s1</span> <span class="n">s2</span><span class="p">)</span>
        <span class="n">f</span> <span class="kt">[]</span>     <span class="kt">[]</span>   <span class="ow">=</span> <span class="mi">0</span>
        <span class="n">f</span> <span class="n">s</span>      <span class="kt">[]</span>   <span class="ow">=</span> <span class="n">length</span> <span class="n">s</span>
        <span class="n">f</span> <span class="kt">[]</span>     <span class="n">s</span>    <span class="ow">=</span> <span class="n">length</span> <span class="n">s</span>
        <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="ow">=</span> <span class="n">lookupS</span> <span class="n">xs</span> <span class="n">ys</span>
                        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span><span class="mi">1</span> <span class="o">+</span> <span class="n">minimum</span> <span class="p">[</span><span class="n">lookupS</span> <span class="n">xs</span> <span class="n">ys</span><span class="p">,</span> <span class="n">lookupS</span> <span class="n">xs</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">),</span> <span class="n">lookupS</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="n">ys</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="generic-memoization">generic memoization</h3>
<p>通过上面的分析, 可以看到, 我们总是可以根据特定的问题构建特定的数据结构来实现memoization. 也就是说, 对于任意的一个函数<code>f :: a -&gt; b</code>(如果f有多个参数, 可以先uncurry), 我们希望能够用一个数据结构来保存计算结果, 也就是<code>(a, b)</code>, 显然, Map就是最理想的数据结构. 问题是Haskell的Map是immutable, 我们没法像imperative programming那样方便的修改, 这个时候就需要用到State, State能够帮助我们解决共享状态的问题(以下实现来源于<a href="http://www.nadineloveshenry.com/haskell/memofib.html">Memoizing function in Haskell</a>):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="kr">type</span> <span class="kt">MemoState</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="n">b</span>

<span class="nf">memorize</span> <span class="ow">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">((</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MemoState</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MemoState</span> <span class="n">a</span> <span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">memorize</span> <span class="n">t</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">evalState</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span> <span class="kr">where</span>
  <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">get</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">maybe</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="n">return</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">x</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">y</span> <span class="ow">&lt;-</span> <span class="n">t</span> <span class="n">f</span> <span class="n">x</span>
        <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">get</span>
        <span class="n">put</span> <span class="o">$</span> <span class="kt">M</span><span class="o">.</span><span class="n">insert</span> <span class="n">x</span> <span class="n">y</span> <span class="n">m</span>
        <span class="n">return</span> <span class="n">y</span>
</code></pre></td></tr></table>
</div>
</div><p>这里<code>t</code>就是我们要memoized的函数, <code>x</code>是<code>t</code>的参数. <code>memorize</code>从一个<code>empty</code>的Map开始运行<code>f x :: MemoState a b</code>并返回它的值. 而<code>f</code>首先用<code>get</code>拿到了当前的状态(也就是Map), 随后检查是否计算过参数为<code>x</code>的结果, 如果是则返回包含结果的<code>MemoState a b</code>, 否则返回<code>g x :: MemoState a b</code>. <code>g</code>的话, 它首先计算参数为<code>x</code>的值, 注意到这个<code>t</code>的类型是<code>(a -&gt; MemoState a b) -&gt; (a -&gt; MemoState a b)</code>, 这和我们之前讨论利用<code>fix</code>的函数类似, 都不递归调用自身, 而是调用额外的函数. 随后, 用<code>get</code>拿到了当前的状态(Map), 再用<code>put</code>更新状态(Map), 最后返回了一个包含结果和新状态的<code>MemoState a b</code>.</p>
<p>注意到这个<code>t</code>的类型, 意味着我们要改写原函数, 我们原先的<code>minEditDist</code>需要改为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- minEditDistM :: ((String, String) -&gt; MemoState (String, String) Int) -&gt; (String, String) -&gt; MemoState (String, String) Int</span>
<span class="nf">minEditDistM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">((</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Int</span>
<span class="nf">minEditDistM</span> <span class="n">f</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span>     <span class="kt">[]</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">return</span> <span class="mi">0</span>
<span class="nf">minEditDistM</span> <span class="n">f</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span>      <span class="kt">[]</span><span class="p">)</span>     <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="n">length</span> <span class="n">s</span>
<span class="nf">minEditDistM</span> <span class="n">f</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span>     <span class="n">s</span><span class="p">)</span>      <span class="ow">=</span> <span class="n">return</span> <span class="o">$</span> <span class="n">length</span> <span class="n">s</span>
<span class="nf">minEditDistM</span> <span class="n">f</span> <span class="p">((</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">))</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>    <span class="ow">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
                                <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">.</span> <span class="n">minimum</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="n">sequenceA</span> <span class="o">$</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="p">[(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">),</span> <span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)),</span> <span class="p">((</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">),</span> <span class="n">ys</span><span class="p">)])</span>
</code></pre></td></tr></table>
</div>
</div><p>所幸的是, 我们可以把<code>minEditDistM</code>, 也就是<code>t</code>的类型定义的更generic. 这样一来, 我们的<code>minEditDist</code>就可以实现为:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- memoized version</span>
<span class="nf">minEditDist</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">minEditDist</span> <span class="n">s1</span> <span class="n">s2</span> <span class="ow">=</span> <span class="n">memorize</span> <span class="n">minEditDistM</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>至此, 我们就得到了泛用的<code>memorize</code>, 我们要做的仅仅是改写原先的函数, 即:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">origin</span> <span class="ow">::</span> <span class="n">a1</span> <span class="ow">-&gt;</span> <span class="n">a2</span> <span class="o">...</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="c1">-- 1. uncurry所有参数, (a1, a2, ...) -&gt; b</span>
<span class="c1">-- 2. 添加额外的f, 替换调用自身的情况, ((a1, a2, ...) -&gt; b) -&gt; (a1, a2, ...) -&gt; b</span>
<span class="c1">-- 3. 修改返回值为monad</span>
<span class="nf">modified</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

<span class="c1">-- memoized version</span>
<span class="nf">originMemo</span> <span class="n">a1</span> <span class="n">a2</span> <span class="o">...</span> <span class="ow">=</span> <span class="n">memorize</span> <span class="n">modified</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="总结">总结</h3>
<p>本文讨论了Haskell中两种memoization的手段, 一种根据具体问题具体的分析, 构建需要的数据结构来保存子问题的结果; 另外一种则利用一个泛用的<code>memoize</code>函数, 按特定的模式修改原函数即可实现memoization. 总体而言, 两种方式各有优劣, 第一种方法需要更精致能够得到更适合问题的解, 第二种方法则提供了泛用性. 如果你有任何问题, 欢迎<a href="mailto:hey_christophe@outlook.com">邮件</a>我</p>
<h3 id="参考">参考</h3>
<ol>
<li><a href="https://wiki.haskell.org/Memoization">Memoization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic programming</a></li>
<li><a href="http://www.nadineloveshenry.com/haskell/memofib.html">Memoizing function in Haskell</a></li>
<li><a href="https://jelv.is/blog/Lazy-Dynamic-Programming/">Lazy Dynamic Programming</a></li>
<li>[Haskell/Understanding monads/State](Haskell/Understanding monads/State)</li>
</ol>

  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>Memoization in Haskell</b><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#memoizing-with-specific-problem">Memoizing with specific problem</a></li>
        <li><a href="#generic-memoization">generic memoization</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#参考">参考</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©Christophe &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
