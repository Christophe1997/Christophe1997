<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>进程 | CastOff</title><meta name=keywords content="System"><meta name=description content="The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:
 create destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process.  The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process."><meta name=author content="Christophe"><link rel=canonical href=https://christophe1997.github.io/posts/process/><meta name=google-site-verification content="CastOff"><link href=https://christophe1997.github.io/assets/css/stylesheet.min.08d6f2005b6ce4ed10207916c0411c66e66f2201e3f7a56e8fb2ccbc4a8b259c.css integrity="sha256-CNbyAFts5O0QIHkWwEEcZuZvIgHj96Vuj7LMvEqLJZw=" rel="preload stylesheet" as=style><link rel=icon href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-112755173-3','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="进程"><meta property="og:description" content="The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:
 create destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process.  The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process."><meta property="og:type" content="article"><meta property="og:url" content="https://christophe1997.github.io/posts/process/"><meta property="article:published_time" content="2018-08-03T13:10:58+00:00"><meta property="article:modified_time" content="2018-08-03T13:10:58+00:00"><meta property="og:site_name" content="CastOff"><meta name=twitter:card content="summary"><meta name=twitter:title content="进程"><meta name=twitter:description content="The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:
 create destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process.  The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"进程","name":"进程","description":"The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:\n create …","keywords":["System"],"articleBody":"The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be included in any interface of an operating system:\n create destroy wait miscellaneous control, most OS provide some kind of method to suspend a process and resume it. status, there are usually interfaces to get some status information about a process.  The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to do before running the process. Some memory must be allocated for the program’s run-time stack, and the OS may also allocate smoe memory for the program’s heap. Also, the os will do some other intialization tasks, particularly as related to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.\nAt any time a process may be running, ready or blocked. Being moved from ready to running means the process has been scheduled and descheduled in contrast. Once a process has become blocked, the OS will keep it as such until some event occurs; at that point, the process moves to the ready state again.\nThe OS is a program, and like any program, it has some key data structures that track various relevant pieces of information. For example, the tracked information about each process in xv6 kernel is shown below:\n// the registers xv6 will save and restore to stop and subsequently restart a process struct context { int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp; }; // the different states a process can be in enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE }; // the information xv6 tracks about each process including its register context and state struct proc { char *mem; // Start of process memory  uint sz; // Size of process memory  char *kstack; // Bottom of kernel stack for this process  enum proc_state state; // Process state  int pid; // Process ID  struct proc *parent; // Parent process  void *chan; // If non-zero, sleeping on chan  int killed; // If non-zero, have been killed  struct file *ofile[NOFILE]; // Open files  struct inode *cwd; // Current directory  struct context context; // Switch here to run process  struct trapframe *tf; // Trap frame for the current interrupt }; Process API Unix presents one of the most intriguing ways to create a new process with a pair of system calls: fork() and exec(). wait() can be used by a process wishing to wait for a process it has created to complete.\nThe fork() creates a process as an(almost) exact copy of the calling process, that means that to the OS, it now looks like there are two copies of the program(the caller) running, and both are about to return from the fork() system call. The newly-created process doesn’t run the main() again, instead it just comes into life as if it had called fork() itself. To distinguish parent and child, the fork() return non-negative PID in parent process, and return 0 in child process, and if it return a negative number, that means it failed. Now there are now two active processes in the system after calling fork, and it’s non-determinism to know which runs first.\nSometimes, it’s useful for a parent to wait a child process to finish what it has been doing, this is accomplished with the wait() system call. the process calls wait() to delay its execution, most until the child has run and exited. When wait() return into parent, returns the PID of child.\nBy giving a name of an executable to exec()(i.e. execvp), it loads code from that executable and overwrites its current code segment with it. The heap and stack and other parts of the memory space of the program are re-initialized. Then the OS simply runs that program, passing in any arguments as the argv of that process. Thus it does not create a new process, rather, it transforms the currently running program into a different running program. A successful call to exec never returns.\nThe spearation of fork() and exec() is essential in building a Unix shell, because it lets the shell run code after the call to fork() but before the call to exec(). For example, shell can redirect the output from stdout to a new file. The way the shell accomplishes this task is quite simple: when the child is created, before calling exec(), the shell closes standard output and open the file, thus any output from the soon-to-be-running program are sent to the file instead of the screen. This works because Unix system start looking for free file descriptors at zero, in this case, STDOUT_FILENO will be the first available one and thus get assigned when open() is called. Subsequent writes by the child process to the standard output file descriptor(i.e. printf) will then be routed transparently to the newly-opened file.\nLimited Direct Execution In order to virtualize the CPU, the operating system needs to somehow share the physical CPU among many jobs running seemingly at the same time. The basic idea is simple: run one process for a little while, then run another one, and so forth.\nTo make a program run as fast as one might expect, not surprisingly OS developers came up with a technique, which we call limited direct execution. The direct execution means run the program directly on the CPU, but only “direct execution” is not enough, the OS need to prevent what we don’t want it to do, thus we need “limited”.\nThere are two phases in the limited direct execution protocol. In the first(at boot time), the kernel initializes the trap table, and the CPU remembers its location for subsequent use. The kernel does so via a privileged instruction. In the second(when running a process), the kernel sets up a few things before using a return-from-trap instruction to start the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap to the process. The process then completes its work, and returns from main(); this usually will return into some stub code which will properly exit the program. At this point, the OS cleans up and we are done.\nIf a process is running on the CPU, this means the OS is not running. So there is a problem that how can OS regain control of the CPU so that it can switch between processes. One old way is waiting system call but the OS can not do much at all if the process refuses to make system call. Another way is to add a timer interrupt, a timer device can be programmed to raise an interrupt every so many milliseconds; when the interrupt is raised, the currently running process is halted, and a pre-configured interrupt handler in the OS runs. At this point, the OS has regained control of the CPU.\nScheduling Policies There are many scheduling algorithms, such as FIFO(first in first out), STCF(shortest time-to-completion first). Choosing which algorithm dependent on which metrics are used. One most well-known approaches to scheduling, known as the Multi-level feedback queue. The MLFQ has a number of distinct queues, each assigned a different priority level. At any given time, a job that is ready to run is on a single queue. And a job with higher priority is chosen to run first. If two jobs have the same priority, we can use round-robin scheduling. The key to MLFQ scheduling therefore lies in how scheduler sets priorities. Rather than giving a fixed priority to each job, MLFQ varies the priority of a job based on its observed behavior. If, for example, a job repeatedly relinquishes the CPU while waiting for input from the keyboard, MLFQ will keep its priority high, as this is how an interactive process might behave.\nMLFQ first assumes the arrived job as a short job, thus giving the job high priority. If it actually is a short job, then it runs quickly and complete, if not, MLFQ slowly move down its priority. And a simple MLFQ rules may be:\n If Priority(A)  Priority(B), A runs. If Priority(A) = Priority(B), A\u0026B run in round-robin. when a job enters the system, it is placed at the highest priority. Once a job uses up its time allotment at a given level, its priority is reduced. after some time period S, move all the jobs in the system to the topmost queue.  Another scheduling policy is lottery scheduling as a proporitional-share scheduling, the basic idea is simple: every so often, hold a lottery to determine which process should get to run next; process that should run more often should be given more chances to win the lottery(to be continued).\n","wordCount":"1520","inLanguage":"en","datePublished":"2018-08-03T13:10:58Z","dateModified":"2018-08-03T13:10:58Z","author":{"@type":"Person","name":"Christophe"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://christophe1997.github.io/posts/process/"},"publisher":{"@type":"Organization","name":"CastOff","logo":{"@type":"ImageObject","url":"https://christophe1997.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://christophe1997.github.io accesskey=h>CastOff</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://christophe1997.github.io/tags/><span>Tags</span></a></li><li><a href=https://christophe1997.github.io/archives/><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>进程</h1><div class=post-meta>August 3, 2018&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Christophe</div></header><div class=post-content><p>The abstraction provided by the OS of a running program is something we call a process. And there are some APIs must be
included in any interface of an operating system:</p><ol><li>create</li><li>destroy</li><li>wait</li><li>miscellaneous control, most OS provide some kind of method to suspend a process and resume it.</li><li>status, there are usually interfaces to get some status information about a process.</li></ol><p>The first thing that the OS must do to run a program is to load its code and any static data into memory, into the address
space of the process. Once the code and static data are loaded into memory, there are a few other things the OS needs to
do before running the process. Some memory must be allocated for the program&rsquo;s <em>run-time stack</em>, and the OS may also
allocate smoe memory for the program&rsquo;s heap. Also, the os will do some other intialization tasks, particularly as related
to I/O, i.e. in Unix systems each process by default has three open file descriptors, for standard input, output and error.</p><p>At any time a process may be <em>running</em>, <em>ready</em> or <em>blocked</em>. Being moved from ready to running means the process has been
<em>scheduled</em> and <em>descheduled</em> in contrast. Once a process has become blocked, the OS will keep it as such until some event
occurs; at that point, the process moves to the ready state again.</p><p>The OS is a program, and like any program, it has some key data structures that track various relevant pieces of information.
For example, the tracked information about each process in xv6 kernel is shown below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>// the registers xv6 will save and restore to stop and subsequently restart a process
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> context {
    <span style=color:#66d9ef>int</span> eip;
    <span style=color:#66d9ef>int</span> esp;
    <span style=color:#66d9ef>int</span> ebx;
    <span style=color:#66d9ef>int</span> ecx;
    <span style=color:#66d9ef>int</span> edx;
    <span style=color:#66d9ef>int</span> esi;
    <span style=color:#66d9ef>int</span> edi;
    <span style=color:#66d9ef>int</span> ebp;
};

<span style=color:#75715e>// the different states a process can be in
</span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };

<span style=color:#75715e>// the information xv6 tracks about each process including its register context and state
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> proc {
    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mem;                   <span style=color:#75715e>// Start of process memory
</span><span style=color:#75715e></span>    uint sz;                     <span style=color:#75715e>// Size of process memory
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>kstack;                <span style=color:#75715e>// Bottom of kernel stack for this process
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>enum</span> proc_state state;       <span style=color:#75715e>// Process state
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> pid;                     <span style=color:#75715e>// Process ID
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> proc <span style=color:#f92672>*</span>parent;         <span style=color:#75715e>// Parent process
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>chan;                  <span style=color:#75715e>// If non-zero, sleeping on chan
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> killed;                  <span style=color:#75715e>// If non-zero, have been killed
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>ofile[NOFILE];  <span style=color:#75715e>// Open files
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>cwd;           <span style=color:#75715e>// Current directory
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> context context;      <span style=color:#75715e>// Switch here to run process
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> trapframe <span style=color:#f92672>*</span>tf;        <span style=color:#75715e>// Trap frame for the current interrupt
</span><span style=color:#75715e></span>};
</code></pre></div><h2 id=process-api>Process API<a hidden class=anchor aria-hidden=true href=#process-api>#</a></h2><p>Unix presents one of the most intriguing ways to create a new process with a pair of system calls: <code>fork()</code> and <code>exec()</code>.
<code>wait()</code> can be used by a process wishing to wait for a process it has created to complete.</p><p>The <code>fork()</code> creates a process as an(almost) <em>exact copy of the calling process</em>, that means that to the OS, it now looks
like there are two copies of the program(the caller) running, and both are about to return from the <code>fork()</code> system call.
The newly-created process doesn&rsquo;t run the <code>main()</code> again, instead it just comes into life as if it had called <code>fork()</code>
itself. To distinguish parent and child, the <code>fork()</code> return non-negative PID in parent process, and return 0 in child
process, and if it return a negative number, that means it failed. Now there are now two active processes in the system
after calling fork, and it&rsquo;s non-determinism to know which runs first.</p><p>Sometimes, it&rsquo;s useful for a parent to wait a child process to finish what it has been doing, this is accomplished with
the <code>wait()</code> system call. the process calls <code>wait()</code> to delay its execution, most until the child has run and exited. When
<code>wait()</code> return into parent, returns the PID of child.</p><p>By giving a name of an executable to <code>exec()</code>(i.e. <code>execvp</code>), it loads code from that executable and overwrites its current
code segment with it. The heap and stack and other parts of the memory space of the program are re-initialized. Then the
OS simply runs that program, passing in any arguments as the <code>argv</code> of that process. Thus it does not create a new process,
rather, it transforms the currently running program into a different running program. A successful call to <code>exec</code> never
returns.</p><p>The spearation of <code>fork()</code> and <code>exec()</code> is essential in building a Unix shell, because it lets the shell run code after
the call to <code>fork()</code> but before the call to <code>exec()</code>. For example, shell can redirect the output from stdout to a new file.
The way the shell accomplishes this task is quite simple: when the child is created, before calling <code>exec()</code>, the shell
closes standard output and open the file, thus any output from the soon-to-be-running program are sent to the file instead
of the screen. This works because Unix system start looking for free file descriptors at zero, in this case, <code>STDOUT_FILENO</code>
will be the first available one and thus get assigned when open() is called. Subsequent writes by the child process to
the standard output file descriptor(i.e. printf) will then be routed transparently to the newly-opened file.</p><h2 id=limited-direct-execution>Limited Direct Execution<a hidden class=anchor aria-hidden=true href=#limited-direct-execution>#</a></h2><p>In order to virtualize the CPU, the operating system needs to somehow share the physical CPU among many jobs running
seemingly at the same time. The basic idea is simple: run one process for a little while, then run another one, and so
forth.</p><p>To make a program run as fast as one might expect, not surprisingly OS developers came up with a technique, which we
call <em>limited direct execution</em>. The direct execution means run the program directly on the CPU, but only &ldquo;direct execution&rdquo;
is not enough, the OS need to prevent what we don&rsquo;t want it to do, thus we need &ldquo;limited&rdquo;.</p><p>There are two phases in the limited direct execution protocol. In the first(at boot time), the kernel initializes the
trap table, and the CPU remembers its location for subsequent use. The kernel does so via a privileged instruction. In
the second(when running a process), the kernel sets up a few things before using a return-from-trap instruction to start
the execution of the process; this switches the CPU to user mode and begins running the process. When the process wishes
to issue a system call, it traps back into the OS, which handles it and once again returns control via a return-from-trap
to the process. The process then completes its work, and returns from <code>main()</code>; this usually will return into some stub
code which will properly exit the program. At this point, the OS cleans up and we are done.</p><p>If a process is running on the CPU, this means the OS is not running. So there is a problem that how can OS regain control
of the CPU so that it can switch between processes. One old way is waiting system call but the OS can not do much at all if
the process refuses to make system call. Another way is to add a <em>timer interrupt</em>, a timer device can be programmed to
raise an interrupt every so many milliseconds; when the interrupt is raised, the currently running process is halted, and
a pre-configured interrupt handler in the OS runs. At this point, the OS has regained control of the CPU.</p><h2 id=scheduling-policies>Scheduling Policies<a hidden class=anchor aria-hidden=true href=#scheduling-policies>#</a></h2><p>There are many scheduling algorithms, such as FIFO(first in first out), STCF(shortest time-to-completion first). Choosing
which algorithm dependent on which metrics are used. One most well-known approaches to scheduling, known as the <em>Multi-level
feedback queue</em>. The MLFQ has a number of distinct queues, each assigned a different priority level. At any given time,
a job that is ready to run is on a single queue. And a job with higher priority is chosen to run first. If two jobs have
the same priority, we can use round-robin scheduling. The key to MLFQ scheduling therefore lies in how scheduler sets
priorities. Rather than giving a fixed priority to each job, MLFQ varies the priority of a job based on its observed
behavior. If, for example, a job repeatedly relinquishes the CPU while waiting for input from the keyboard, MLFQ will
keep its priority high, as this is how an interactive process might behave.</p><p>MLFQ first assumes the arrived job as a short job, thus giving the job high priority. If it actually is a short job, then
it runs quickly and complete, if not, MLFQ slowly move down its priority. And a simple MLFQ rules may be:</p><ol><li>If Priority(A) > Priority(B), A runs.</li><li>If Priority(A) = Priority(B), A&B run in round-robin.</li><li>when a job enters the system, it is placed at the highest priority.</li><li>Once a job uses up its time allotment at a given level, its priority is reduced.</li><li>after some time period S, move all the jobs in the system to the topmost queue.</li></ol><p>Another scheduling policy is <em>lottery scheduling</em> as a proporitional-share scheduling, the basic idea is simple: every so
often, hold a lottery to determine which process should get to run next; process that should run more often should be
given more chances to win the lottery(to be continued).</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://christophe1997.github.io/tags/system>System</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on twitter" href="https://twitter.com/intent/tweet/?text=%e8%bf%9b%e7%a8%8b&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f&hashtags=System"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f&title=%e8%bf%9b%e7%a8%8b&summary=%e8%bf%9b%e7%a8%8b&source=https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f&title=%e8%bf%9b%e7%a8%8b"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%bf%9b%e7%a8%8b%20-%20https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 进程 on telegram" href="https://telegram.me/share/url?text=%e8%bf%9b%e7%a8%8b&url=https%3a%2f%2fchristophe1997.github.io%2fposts%2fprocess%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2020 <a href=https://christophe1997.github.io>CastOff</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});"></script><script defer src=https://christophe1997.github.io/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>