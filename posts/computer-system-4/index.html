<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-112755173-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  computer system 4 &ndash; CastOff

    </title>
    
    
    <meta name="description" property="og:description" content="Linking Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into machine code; at load time, when the program is loaded into memory and executed by the loader; and even at run time, by application programs. On modern systems, linking is performed automatically by programs called linkers.|">
    

    <meta name="apple-mobile-web-app-title" content="CastOff">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://christophe1997.github.io">
    CastOff
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item " href="/posts/">
      
      <span>Blogs</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item " href="/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">computer system 4</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/notes' class="muted-link">
  <span class="Label Label--gray-darker">notes</span>
</a>



<a href='/tags/system' class="muted-link">
  <span class="Label Label--gray">system</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-12-04. Published at: 2018-06-10.">
        
          Lastmod: 2019-12-04
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <h2 id="linking">Linking</h2>
<p>Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded
(copied) into memory and executed. Linking can be performed at compile time, when the source code is translated into
machine code; at load time, when the program is loaded into memory and executed by the <em>loader</em>; and even at run time, by
application programs. On modern systems, linking is performed automatically by programs called <em>linkers</em>.</p>
<!-- raw HTML omitted -->
<h3 id="static-linking">static linking</h3>
<p><em>Static linker</em> such as the Unix ld program take as input a collection of relocatable object files and command-line arguments
and generate as output a fully linked executable object file that can be loaded and run. To build the executable, the
linker must perform two main tasks:</p>
<ol>
<li><em>Symbol resolution</em>. Object files define and reference symbols. The purpose of symbol resolution is to associate each
symbol reference with exactly one symbol definition.</li>
<li><em>Relocation</em>. Compilers and assemblers generate code and data sections that start at address 0. The linker <em>relocates</em>
these sections by associating a memory location with each symbol definition, and then modifying all of the references
to those symbols so that they point to this memory location.</li>
</ol>
<h3 id="object-file">object file</h3>
<p>Object files are merely collections of blocks of bytes, it comes in three forms:</p>
<ul>
<li><em>Relocatable object file</em>. Contains binary code and data in a form that can be combined with other relocatable object
files at compile time to create an executable object file.</li>
<li><em>Executable object file</em>. Contains binary code and datain a form that can be copied directly into momory and executed.</li>
<li><em>Shared object file</em>. A special type of relocatable object file that can be loaded into memory and linked dynamically,
at either load time or run time.</li>
</ul>
<p>Modern x86-64 Linux and Unix system use <em>Executable and Linkable Formate</em>(ELF) to format object file, A typical ELF
relocatable object file contains the following sections:</p>
<ul>
<li>.text: The machine code of the compiled program.</li>
<li>.rodata: Read-only data such as the format strings in printf statements, and jump tables for switch statements.</li>
<li>.data: Initialized global C variables.</li>
<li>.bss: Uninitialized global C variables. This section occupies no actual space in the object file; it is merely a place
holder.</li>
<li>.symtab: A symbol table with information about functions and global variables that are defined and referenced in the
program.</li>
<li>.rel.text: A list of locations in the .text section that will need to be modified when the linker combines this object
file with others.</li>
<li>.rel.data: Relocation information for any global variables that are referenced or defined by the module.</li>
<li>.debug: A debugging symbol table with entries for local variables and typedefs defined in the program, global variables
defined and referenced in the program, and the original C source file.</li>
<li>.line: A mapping between line numbers in the original C source program and machine code instructions in the .text section.</li>
<li>.strtab: A string table for the symbol tables in the .symtab and .debug sections, and for the section names in the
section headers.</li>
</ul>
<p>The .debug and .line sections only present if the compiler driver is invoked with the -g option.</p>
<h3 id="symbol">symbol</h3>
<p>Each relocatable object module m, has a symbol table that contains information about the symbols that are defined and
referenced by m. In the context of a linker, there are three different kinds of symbols:</p>
<ul>
<li><em>Global symbols</em> that are defined by module m and that can be referenced by other modules. Global linker symbols
correspond to <em>nonstatic</em> C functions and global variables that are defined without the C <code>static</code> attribute.</li>
<li><em>externals</em> that are the Global symbols referenced by module m but defined by some other module.</li>
<li><em>Local symbols</em> that are defined and referenced exclusively by module m. Some local linker symbols correspond to C
functions and global variables that are defined with the <code>static</code> attribute. These symbols are visible anywhere within
module m, but cannot be referenced by other modules.</li>
</ul>
<p>Interestingly, local procedure variables that are defined with the C static attribute are not managed on the stack.
Instead, the compiler allocates space in .data or .bss for each definition and creates a local linker symbol in the
symbol table with a unique name.</p>
<p>Symbol tables are built by assemblers, using symbols exported by the compiler into the assembly-language .s file, it
contains an array of entries, each entry has the format below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">name</span><span class="p">;</span>           <span class="cm">/* String table offset */</span>
<span class="kt">char</span> <span class="nl">type</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>        <span class="cm">/* Function or data (4 bits) */</span>
     <span class="nl">binding</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>     <span class="cm">/* Local or global (4 bits) */</span>
<span class="kt">char</span> <span class="n">reserved</span><span class="p">;</span>      <span class="cm">/* Unused */</span>
<span class="kt">short</span> <span class="n">section</span><span class="p">;</span>      <span class="cm">/* Section header index */</span>
<span class="kt">long</span> <span class="n">value</span><span class="p">;</span>          <span class="cm">/* Section offset, or absolute address */</span>
<span class="kt">long</span> <span class="n">size</span><span class="p">;</span>           <span class="cm">/* Object size in bytes */</span>
<span class="p">}</span> <span class="n">Elf64_Symbol</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol
tables of its input relocatable object files. It's much easy to reference local symbols than global symbols.The compiler
allows only one definition of each local symbol per module. Overloaded functions in C++ and Java work because the compiler
encodes each unique method and parameter list combination into a unique name for the linker, which is known as mangling.</p>
<p>At compile time, the compiler exports each global symbol to the assembler as either <em>strong</em> or <em>weak</em>, and the assembler
encodes this information implicitly in the symbol table of the relocatable object file. Functions and initialized global
variables get strong symbols. Uninitialized global variables get weak symbols. Given this notion of string and weak symbols,
Unix linkers use the following rules for dealing with multiply defined:</p>
<ol>
<li>Multiple strong symbols are not allowed.</li>
<li>Given a strong symbol and multiple weak symbols, choose the strong symbol.</li>
<li>Given multiple weak symbols, choose any of the weak symbols.</li>
</ol>
<h2 id="exceptional-control-flow">Exceptional control flow</h2>
<p>Exceptions can be divided into four classes: <em>interrupts</em>, <em>traps</em>, <em>faults</em> and <em>aborts</em>.</p>
<p><em>Interrupts</em> occur asynchronously as a result of signals from I/O devices that are external to the processor. Exception
handlers for hardware interrupts are often called <em>interrupt handlers</em>. After the current instruction finishes executing,
the processor notices that the interrupt pin has gone high, reads the exception number from the system bus, and then calls
the appropriate interrupt handler. When the handler return, it returns control to next instruction. The remaining classes
of exceptions(traps, falusts and aborts) occur synchronously as a result of executing the current instruction. We refer
to this instruction as the <em>faluting instruction</em>.</p>
<p><em>Traps</em> are intentional exceptions that occur as a result of executing an instruction. The most import use of traps is
to provide a procedure-like interface between user programs and the kernel known as <em>system call</em>. From a programmer's
perspective, a system call is identical to a regular function call. However, regular functions run in user mode, which
restricts the types of instructions they can execute, and they acess the same stack as the calling function, while a
system call runs in kernel mode, which allows it to execute instructions, and accesses a stack defined in the kernel.</p>
<p><em>Faults</em> result from error conditions that a handler might be able to correct. When a fault occurs, the processor
transfers control to the fault handler. If the handler is able to correct the error condition, it returns control to the
faulting instruction, thereby reexecuting it. Otherwise, the handler returns to an abort routine in the kernel that
terminates the application program that caused the fault.</p>
<p><em>Aborts</em> result from unrecoverable faltal errors, typically hardware errors.</p>
<p>x86-64 system has up to 256 different exception types. Numbers in the range from 0 to 31 corresnpond to execeptions that
are defined by Intel, while numbers in the range from 32 to 255 correspond to interrupts and traps that are defined by
the operating system.</p>
<h3 id="processes">Processes</h3>
<p>Exceptions are the basic building blocks that allow the operating system to provide the notion of a <em>process</em>, one of
the most profound and successful ideas in computer science. The classic definition of a process is an <em>instance of a
program in execution</em>. A process provides two key abstractions: An independent logical control flow and A private address
space.</p>
<p>Unix provides a number of system calls for manipulating processes from C programs. Each process has a unique positive
(nonzero) process ID (PID). The getpid function returns the PID of the calling process. The getppid function returns the
PID of its parent. The <em>fork</em> function creates a new running child process. The fork function is called once but returns
twice: once in the calling process (the parent), and once in the newly created child process. In the parent, fork returns
the PID of the child. In the child, fork returns a value of 0. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">child : x=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">+</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">parent: x=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">-</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And it's result in Unix system is</p>
<pre><code>parent: x=0
child: x=2
</code></pre><p>Here you can see the fork function call once, return twice. And the parent and the child are sperate processes that run
concurrently, we can never make assumptions about the order of the two process. Those two process also share duplicate but
separate address spaces, they both have x equals to 1, but they do different things to x sperately. Also they share files,
that means the child process inherits all of parent's open files.</p>
<h3 id="common-memoryrelated-bugs-in-c">Common memory-related bugs in C</h3>
<ol>
<li>
<p>Dereference bad pointers: If we attempt to dereference a pointer into the unmapped virtual address or the read-only
areas and write, the operating system will terminate the program with a segmentation exception. But if the address is
legal, then it will never report a problem, which usually cause baffling consequences.</p>
</li>
<li>
<p>Read uninitialized memory: While bss memory locations(such as unintialized global C variables) are always initialized
to zero by the loader, this is not true for heap memory. You should always zero it explicitly or use calloc.</p>
</li>
<li>
<p>Allow stack buffer overflows: A program has a buffer overflow bug if it writes to a target buffer on the stack without
examining the size of the input string.</p>
</li>
<li>
<p>Assume that pointers and the objects they point to are the same size, It is always incorrect.</p>
</li>
<li>
<p>Make off-by-one errors: index out of range.</p>
</li>
<li>
<p>Reference a pointer instead of the object it points to.</p>
</li>
<li>
<p>Misunderstande pointer arithmetic.</p>
</li>
<li>
<p>Reference nonexistent variables: always means return a pointer point to the local variable.</p>
</li>
<li>
<p>Reference data in free heap blocks: reference the data after it frees.</p>
</li>
<li>
<p>Introduce memory leaks: memory leaks are particularly serious for programs such as daemons and servers, which by
definition never terminate.</p>
</li>
</ol>
<h2 id="systemlevel-io">System-level I/O</h2>
<p>A Unix file is a sequence of m bytes:
$$ B_0, B_1, \cdots, B_k, \cdots, B_{m-1} $$
All I/O devices, such as networks, disks, and terminals, are modeled as files, and all input and output is performed by
reading and writing the appropriate files.This elegant mapping of devices to files allows the Unix kernel to export a
simple, lowlevel application interface, known as Unix I/O, that enables all input and output to be performed in a uniform
and consistent way:</p>
<ol>
<li>Opening files.</li>
<li>Changing the current file position.</li>
<li>Reading and writing files.</li>
<li>Closing files.</li>
</ol>
<p>Every Unix file has a type to show their role in system:</p>
<ol>
<li><em>regular file</em> contains any data, applications always need to distinguish between text file and binary file.</li>
<li><em>directory</em> contains a set of links. Each link maps a filename to a file. &ldquo;.&rdquo; links the directory itself, and &ldquo;..&rdquo;
links the parent directory.</li>
<li><em>socket</em> is used for cross-network communication.
and so on(named pipe, symbolic link). Every process have a <em>current working directory</em> in its context to refer the work
location.</li>
</ol>

  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>computer system 4</b><nav id="TableOfContents">
  <ul>
    <li><a href="#linking">Linking</a>
      <ul>
        <li><a href="#static-linking">static linking</a></li>
        <li><a href="#object-file">object file</a></li>
        <li><a href="#symbol">symbol</a></li>
      </ul>
    </li>
    <li><a href="#exceptional-control-flow">Exceptional control flow</a>
      <ul>
        <li><a href="#processes">Processes</a></li>
        <li><a href="#common-memoryrelated-bugs-in-c">Common memory-related bugs in C</a></li>
      </ul>
    </li>
    <li><a href="#systemlevel-io">System-level I/O</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    Â©Christophe &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
