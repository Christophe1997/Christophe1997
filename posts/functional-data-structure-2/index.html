<!DOCTYPE html>
<html>
  <head>
    
    
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  functional data structure 2 &ndash; CastOff

    </title>
    
    
    <meta name="description" property="og:description" content="amortization Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about the running time of any individual operation.
For instance, given a sequence of n operations, we may wish to bound the total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time.|">
    

    <meta name="apple-mobile-web-app-title" content="CastOff">
    
    
    <link rel="icon" href="/favicon-64.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="mask-icon" size="any" href="/pinned-icon.svg">
    
    
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://christophe1997.github.io">
    CastOff
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item " href="/posts/">
      
      <span>Blogs</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item " href="/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">functional data structure 2</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/notes' class="muted-link">
  <span class="Label Label--gray-darker">notes</span>
</a>



<a href='/tags/ocaml' class="muted-link">
  <span class="Label Label--gray">OCaml</span>
</a>

<a href='/tags/fp' class="muted-link">
  <span class="Label Label--gray">FP</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-12-04. Published at: 2018-07-24.">
        
          Lastmod: 2019-12-04
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <h2 id="amortization">amortization</h2>
<p>Implementations with good amortized bounds are often simpler and faster than implementations with comparable worst-case
bounds. Given a sequence of operations, we may wish to know the running time of the entire sequence, but not care about
the running time of any individual operation.</p>
<!-- raw HTML omitted -->
<p>For instance, given a sequence of n operations, we may wish to bound the
total running time of the sequence by O(n) without insisting than every individual operation run in O(1) time. We might
be satisfied if a few operations run in O(log n) or even O(n) time, provided the total cost of the sequence is only O(n).
This freedom opens up a wide design space of possible solutions, and often yields new solutions that are simpler and
faster than worst-case solutions with equivalent bounds.</p>
<p>To provide an amortized bound, one defines the amortized cost of each operation and then proves that, for any sequence
of operations, the total amortized cost of the operations in an upper bound on the total actual cost,
$$ \sum_{i=1}^m a_i \geq \sum_{i=1}^m t_i $$
where $ a_i $ is the amortized cost of operation i, $t_i$ is the actual cost of operation i, and m is the total number
of operations. Usually, in fact, one proves a slightly strong result: that at any intermediate stage in a sequence of
operations, the accumulated amortized cost is an upper bound on the accumulated actual cost,
$$ \sum_{i=1}^j a_i \geq \sum_{i=1}^j t_i $$
for any j. The difference between the accumulated amortized costs and the accumulated actual costs is called the _accumulated
savings_. Thus, the accumulated amortized costs are an upper bound on the accumulated actual costs whenever the accumulated
saving is non-negative.</p>
<p>Amortization allows for occasional operations to have actual costs that exceed their amortized costs, such operations are
called <em>expensive</em>, while the operations whose actual costs are less than their amortized costs are called <em>cheap</em>. It's
easy to see that expensive operations decrease the accumulated saving and cheap operations increase it. The key to proving
amortized bounds is to show that expensive operations occur only when the accumulated saving are sufficient to cover the
remaining cost.</p>
<p>There are two techniques for analyzing amortized data structures: the <em>banker's method</em> and the <em>physicist's method</em>. In
the banker's method, the accumulated saving are represented as <em>credits</em> that are associated with individual locations
in the data structure. These credits are used to pay for future accesses to these locations. The amortized cost of any
operation is defined to be the actual cost of the operation plus the credits allocated by the operation minus the credits
spent by the operation:
$$ a_i = t_i + c_i - \bar{c_i} $$
where $ c_i $ is the number of credits allocated by operation i and $\bar{c_i}$ is the number of credits spent by operation
i. Every credit must be allocated before it is spent, and no credit may be spent more than once. Therefore, $\sum c_i \geq
\sum \bar{c_i}$ which in turn guarantees that $\sum a_i \geq \sum t_i$, as desired. Proofs using the banker's method
typically define a <em>credit invariant</em> that regulates the distribution of credits in such a way that, whenever an expensive
operation might occur, sufficient credits have been allocated in the right locations to cover its cost.</p>
<p>In the physicist's method, one describes a function $\Phi$ that maps each object d to a real number called the <em>potential</em>
of d. The function $\Phi$ is typically chosen so that the potential is initially zero and is always non-negative. Then the
potential represents a lower bound on the accumulated savings.</p>
<p>Let d_i be the output of operation i and input of operation i + 1. Then the amortized cost of operation i is defined to
be the actual cost plus the change in potential between $d_{i-1}$ and $d_i$:
$$ a_i = t_i + \Phi(d_i) + \Phi(d_{i-1}) $$
so, the accumulated actual costs of the sequence of operations are:
$$ \sum_{i=1}^j t_i = \sum_{i=1}^j a_i + \Phi(d_0) - \Phi(d_j) $$
Provided $\Phi$ is chosen in such a way that $\Phi(d_0)$ is zero and $\Phi(d_j)$ is non-negative, then we conclude that
the accumulated amoritized costs are an upper bound on the accumulated actual costs.</p>
<h3 id="queue">queue</h3>
<p>We illustrate the banker's and physicist's methods by analyzing a simple functional implementation of the FIFO queue
abstraction as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">module</span> <span class="k">type</span> <span class="nc">Queue</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  
  <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  
  <span class="k">val</span> <span class="n">isEmpty</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  
  <span class="c">(*</span><span class="c">*</span><span class="c"> snoc means &#34;cons on the right&#34; </span><span class="c">*)</span>
  <span class="k">val</span> <span class="n">snoc</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  
  <span class="k">val</span> <span class="n">head</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span>
  
  <span class="k">val</span> <span class="n">tail</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>The most common implementation of queues in a purely functional setting is a pair of lists, <em>front</em> contains the front
elements of the queue in the correct order and <em>rear</em> contains the rear elements of the queue in reverse order:</p>
<pre><code>type 'a t = 'a list * 'a list
</code></pre><p>in this representation, the head of the queue is the first element of <em>front</em>, and the last element of the queue is the
first element of <em>rear</em>, so the remains can implement straightforward:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span>

<span class="k">let</span> <span class="n">checkf</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">rear</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">rear</span><span class="o">,</span> <span class="bp">[]</span><span class="o">)</span>
  <span class="o">|</span> <span class="n">queue</span> <span class="o">-&gt;</span> <span class="n">queue</span>

<span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span><span class="o">,</span> <span class="n">rear</span> <span class="o">-&gt;</span> <span class="n">checkf</span> <span class="o">(</span><span class="n">tl</span><span class="o">,</span> <span class="n">rear</span><span class="o">)</span>

<span class="k">let</span> <span class="n">snoc</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">front</span><span class="o">,</span> <span class="n">rear</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">checkf</span> <span class="o">(</span><span class="n">front</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rear</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Here we use the auxiliary function <code>checkf</code> so that we check if the front is empty and then reverse the rear as the new
front. Notice that, if <em>front</em> were empty when <em>rear</em> was not, then the first element of the queue would be the last
element of rear, which would take O(n) time to access. By maintaining this invariant, we guarantee that head can always
find the first element in O(1) time, and we also know that if the <em>front</em> is empty, then so is <em>rear</em>.</p>
<p>Now we show that snoc and tail both take O(1) amortized time using either the banker's method or the physicist's method,
though <code>tail</code> takes O(n) time in the worse-case. Using the banker's method, we maintain a credit invariant that every element
in the real list is assiciated with a single credit. Every snoc into a non-empty queue takes one actual step and allocates
a credit to the new element of the rear list, for an amortized cost of two. Every tail that does not reverse the rear list,
takes one actual step and neither allocates nor spends any credits, for an amortized cost of one. Finally, every tail that
does reverse the rear list takes $ m+1 $ actual steps, where m is the length of the rear list, and spends the m credits
contained by that list, for an amortized cost of $ m + 1 - m = 1 $.</p>
<p>Using the physicist's method, we define the potential function $\Phi$ to be the length of the rear list. Then every snoc
into a non-empty queue takes one actual step and increases the potential by one, for an amortized cost of two. Every tail
that does not reverse the rear list takes one actual step and leaves the potential unchanged, for an amortized cost of
one. Finally, every tail that does reverse the rear list takes $m + 1$ actual steps and sets the new rear list to [],
decreasing the potential by m, for an amortized cost of $ m+1-m = 1 $</p>
<h3 id="splay-heaps">splay heaps</h3>
<p>Splay trees are perhaps the most famous and successful of all amortized data structure. Splay trees are a close relative
of balanced binary search trees, but they maintain no explicit balance information. Instead, every operation blindly
restructures the tree using some simple transformations that tend to increase balance. Although any individual operation
can take as much as O(n) time, but every operation runs in O(log n) amortized time. A major difference between splay trees
and balanced binary search trees such as the red-black trees is that splay trees are restructured even during queries instead
of only during updates. This property makes it awkward to use splay trees to implement abstractions such as sets or finite
maps in a purely functional setting, because the query would have to return the new tree along with the answer. For some
abstractions, however, the queries are limited enough to avoid these problems. A good example is the heap abstraction,
where the only interesting query is findMin. In fact, splay tree make an excellent implementation of heaps.</p>
<p>The representation of splay tree in identical to that of unbalanced binary search trees:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">elem</span> <span class="o">*</span> <span class="n">t</span>
</code></pre></td></tr></table>
</div>
</div><p>unlike the unbalanced binary search trees, we allow duplicate elements within a single tree. Unlike the insertion into
ordinary binary search trees, we just partition the existing tree into two subtrees, one containing all the elements smaller
than or equal to the new element and one in contrast, and then construct a new tree where the root is the new element
and other two as its children:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">smaller</span> <span class="n">x</span> <span class="n">t</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">bigger</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>and bigger implement as bellow(smaller implement same way):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">bigger</span> <span class="n">pivot</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
      <span class="k">then</span> <span class="n">bigger</span> <span class="n">pivot</span> <span class="n">right</span>
      <span class="k">else</span> <span class="k">match</span> <span class="n">left</span> <span class="k">with</span> 
        <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
        <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
          <span class="k">then</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">bigger</span> <span class="n">pivot</span> <span class="n">right1</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
          <span class="k">else</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">bigger</span> <span class="n">pivot</span> <span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">right1</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that we restructure the tree to make in more balanced: every time we follow two left branches in a row, we rotate
those two nodes. Although, the tree may be still not balance in the usual sense, the new tree will be much more balanced
than the original tree. In fact, this is the guiding principle of splay trees: search paths should be restructured to
reduce the depth of every node in the path by about half.</p>
<p>Also we can combine bigger and smaller as one function <code>partition</code>, which return a pair:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">as</span> <span class="n">tree</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
    <span class="k">then</span> <span class="k">match</span> <span class="n">right</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">tree</span><span class="o">,</span> <span class="nc">Leaf</span>
      <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
        <span class="k">then</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">right1</span> <span class="k">in</span>
          <span class="nc">Node</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">left1</span><span class="o">)</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">small</span><span class="o">)</span><span class="o">,</span> <span class="n">big</span>
        <span class="k">else</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">left1</span> <span class="k">in</span>
          <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">small</span><span class="o">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">big</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span>
    <span class="k">else</span> <span class="k">match</span> <span class="n">left</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="n">tree</span>
      <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
        <span class="k">then</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">right1</span> <span class="k">in</span>
          <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">small</span><span class="o">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">big</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
        <span class="k">else</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">left1</span> <span class="k">in</span>
          <span class="n">small</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">big</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">right1</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The remains are straightforward:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(*</span><span class="c">*</span><span class="c"> splayHeap.ml </span><span class="c">*)</span>
<span class="k">open</span> <span class="nc">Core</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">Heap</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">type</span> <span class="n">elem</span>

  <span class="k">exception</span> <span class="nc">Empty</span>

  <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">isEmpty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>

  <span class="k">val</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">elem</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">merge</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">findMin</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">elem</span>
  <span class="k">val</span> <span class="n">deleteMin</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">(</span><span class="nc">Elem</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="nc">Heap</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elem</span> <span class="o">=</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span> 
  <span class="k">type</span> <span class="n">elem</span> <span class="o">=</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">t</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="n">t</span> <span class="o">*</span> <span class="n">elem</span> <span class="o">*</span> <span class="n">t</span>

  <span class="k">exception</span> <span class="nc">Empty</span>

  <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nc">Leaf</span>

  <span class="k">let</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">as</span> <span class="n">tree</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
      <span class="k">then</span> <span class="k">match</span> <span class="n">right</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">tree</span><span class="o">,</span> <span class="nc">Leaf</span>
        <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
          <span class="k">then</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">right1</span> <span class="k">in</span>
            <span class="nc">Node</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">left1</span><span class="o">)</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">small</span><span class="o">)</span><span class="o">,</span> <span class="n">big</span>
          <span class="k">else</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">left1</span> <span class="k">in</span>
            <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">small</span><span class="o">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">big</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span>
      <span class="k">else</span> <span class="k">match</span> <span class="n">left</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="n">tree</span>
        <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">pivot</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
          <span class="k">then</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">right1</span> <span class="k">in</span>
            <span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">small</span><span class="o">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">big</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
          <span class="k">else</span> <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">left1</span> <span class="k">in</span>
            <span class="n">small</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">big</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">right1</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">t</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">x</span> <span class="n">t</span> <span class="k">in</span>
    <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">merge</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">t2</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> 
      <span class="k">let</span> <span class="n">small</span><span class="o">,</span> <span class="n">big</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">v</span> <span class="n">t2</span> <span class="k">in</span>
      <span class="nc">Node</span> <span class="o">(</span><span class="n">merge</span> <span class="n">small</span> <span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">merge</span> <span class="n">big</span> <span class="n">right</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">findMin</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">v</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">findMin</span> <span class="n">left</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">deleteMin</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">right</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">right2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">right1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">right2</span><span class="o">)</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="n">right1</span><span class="o">)</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">right2</span><span class="o">)</span> <span class="o">-&gt;</span> 
      <span class="nc">Node</span> <span class="o">(</span><span class="n">deleteMin</span> <span class="n">left1</span><span class="o">,</span> <span class="n">v1</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">right1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">right2</span><span class="o">)</span><span class="o">)</span>

<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>And the amortized cost of insert and deleteMin run in O(log n) time, proofs are omited.</p>
<p>A particularly pleasant feature of splay trees is that they naturally adapt to any order that happens to be present in
the input data. For example, using splay heaps to sort an already sorted list takes only O(n) time rather than O(nlog n)
time. Leftist heaps also share this property, but only for decreasing sequences. Splay heaps excel on both increasing and
decreasing sequences, as well as on sequence that are only partially sorted.</p>
<h3 id="pairing-heaps">pairing heaps</h3>
<p>Pairing heaps are simple to implement and perform extremely well in parctice, but they have resisted analysis for over
ten years. Pairing heaps are heap-ordered multiway trees, as defined:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="n">elem</span> <span class="o">*</span> <span class="n">t</span> <span class="kt">list</span>
</code></pre></td></tr></table>
</div>
</div><p>We allow only well-formed trees, in which <code>Leaf</code> never occurs in the child list of <code>Node</code>. Pairing heaps get their name
from deleteMin operation. <code>deleteMin</code> discards the root and then merges the children in two passes. The first pass merges
children in pairs from left to right. The second pass merges the resulting trees from right to left:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">mergePairs</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
  <span class="o">|</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">h</span>
  <span class="o">|</span> <span class="n">h1</span> <span class="o">::</span> <span class="n">h2</span> <span class="o">::</span> <span class="n">hs</span> <span class="o">-&gt;</span> <span class="n">merge</span> <span class="o">(</span><span class="n">merge</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span> <span class="o">(</span><span class="n">mergePairs</span> <span class="n">hs</span><span class="o">)</span>

<span class="k">let</span> <span class="n">deleteMin</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">hs</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">mergePairs</span> <span class="n">hs</span> 
</code></pre></td></tr></table>
</div>
</div><p>and others are straightforward:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(*</span><span class="c">*</span><span class="c"> pairing heaps </span><span class="c">*)</span>
<span class="k">open</span> <span class="nc">Core</span>

<span class="k">module</span> <span class="k">type</span> <span class="nc">Heap</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="n">t</span>
  <span class="k">type</span> <span class="n">elem</span>

  <span class="k">exception</span> <span class="nc">Empty</span>

  <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">isEmpty</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>

  <span class="k">val</span> <span class="n">insert</span> <span class="o">:</span> <span class="n">elem</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">merge</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">findMin</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">elem</span>
  <span class="k">val</span> <span class="n">deleteMin</span> <span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span>

  <span class="k">val</span> <span class="n">fromList</span> <span class="o">:</span> <span class="n">elem</span> <span class="kt">list</span> <span class="o">-&gt;</span> <span class="n">t</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">(</span><span class="nc">Elem</span> <span class="o">:</span> <span class="nc">Comparable</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="nc">Heap</span> <span class="k">with</span> <span class="k">type</span> <span class="n">elem</span> <span class="o">=</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">elem</span> <span class="o">=</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">t</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="n">elem</span> <span class="o">*</span> <span class="n">t</span> <span class="kt">list</span>

  <span class="k">exception</span> <span class="nc">Empty</span>

  <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nc">Leaf</span>

  <span class="k">let</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

  <span class="k">let</span> <span class="n">merge</span> <span class="n">h1</span> <span class="n">h2</span> <span class="o">=</span> <span class="k">match</span> <span class="n">h1</span><span class="o">,</span> <span class="n">h2</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="o">_</span> <span class="k">as</span> <span class="n">h</span> <span class="o">|</span> <span class="o">_</span> <span class="k">as</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">h</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">hs1</span><span class="o">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">hs2</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">if</span> <span class="nn">Elem</span><span class="p">.</span><span class="n">compare</span> <span class="n">v1</span> <span class="n">v2</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">0</span>
      <span class="k">then</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">h2</span> <span class="o">::</span> <span class="n">hs1</span><span class="o">)</span>
      <span class="k">else</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">h1</span> <span class="o">::</span> <span class="n">hs2</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">h</span> <span class="o">=</span> <span class="n">merge</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="bp">[]</span><span class="o">)</span><span class="o">)</span> <span class="n">h</span>

  <span class="k">let</span> <span class="n">mergePairs</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span>
    <span class="o">|</span> <span class="o">[</span><span class="n">h</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">h</span>
    <span class="o">|</span> <span class="n">h1</span> <span class="o">::</span> <span class="n">h2</span> <span class="o">::</span> <span class="n">hs</span> <span class="o">-&gt;</span> <span class="n">merge</span> <span class="o">(</span><span class="n">merge</span> <span class="n">h1</span> <span class="n">h2</span><span class="o">)</span> <span class="o">(</span><span class="n">mergePairs</span> <span class="n">hs</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">findMin</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">hs</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span>

  <span class="k">let</span> <span class="n">deleteMin</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">hs</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">mergePairs</span> <span class="n">hs</span> 

<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that <code>findMin</code>, <code>insert</code> and <code>merge</code> all run in O(1) worst-case time, however, deleteMin can take up to O(n) time
in the worst case. And <code>deleteMin</code> run in O(log n) amortized time.</p>
<p>All amortized data structures we have discussed are tremendously effective in pratice. Unfortunately, they perform a
bad in persistence. Let q be the result of inserting n elements into an initially empty queue, so that the front list
of q contains only a single element and the rear list contains n - 1 elements. So if we use q persistently by taking
tail n times, each call takes n actual steps. And the total actual cost, including the time to build q, is $ n^2 + n $,
Thus the operation can not take O(1) amortized time, and this can be solved via lazy evaluation.</p>
<h2 id="numerical-representations">numerical representations</h2>
<p>Consider the usual representations of lists and natural numbers, along with several typical functions on each type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span>

<span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">xs</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  
<span class="k">let</span> <span class="k">rec</span> <span class="n">append</span> <span class="n">xs</span> <span class="n">ys</span> <span class="o">=</span> <span class="k">match</span> <span class="n">xs</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Nil</span> <span class="o">-&gt;</span> <span class="n">ys</span>
  <span class="o">|</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="n">append</span> <span class="n">tl</span> <span class="n">ys</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="n">nat</span> <span class="o">=</span> <span class="nc">Zero</span> <span class="o">|</span> <span class="nc">Succ</span> <span class="k">of</span> <span class="n">nat</span>

<span class="k">let</span> <span class="n">pred</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Succ</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">PredZero</span>
  
<span class="k">let</span> <span class="k">rec</span> <span class="n">plus</span> <span class="n">n1</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">match</span> <span class="n">n1</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">-&gt;</span> <span class="n">n2</span>
  <span class="o">|</span> <span class="nc">Succ</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="nc">Succ</span> <span class="o">(</span><span class="n">plus</span> <span class="n">n</span> <span class="n">n2</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Other than the fact that list contain elements and natural numbers do not, these implementations are virtually identical.
Binomial heaps exhibit a similar relationship with binary numbers. These examples suggest a strong anology between representations
of the number n and representations container objects of size n. Functions on the container strongly resemble arithmetic
functions on the number. This analogy can be exploited to design new implementations of container abstractions &ndash; simply
choose a representation of natural numbers with certain desired properties and define the function on the container objects
accordingly. This design fashion is called <em>numerical representation</em>.</p>
<p>Given a positional number system, we can implement a numerical representation based on than number system as a sequence
of trees. For example, the binary representation of 73 is 1001001, so a collection of size 73 in a binary numberical
representation would contain three trees, of size 1, 8 and 64. Trees in numerical representations typically exhibit a
very regular structure, for example, in binary numerical representations, all trees have size that are powers of 2. And
there are three common kinds of trees that exhibit this structure are <em>complete binary leaf trees</em>, <em>binomial trees</em>, and
<em>pennants</em>. Each tree with rank r has $ 2^r $ element.</p>
<h3 id="binary-randomaccess-lists">binary random-access lists</h3>
<p>A random-access list, also called a one-sided flexible array, is a data structure that supports array-like lookup and
update functions:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">module</span> <span class="k">type</span> <span class="nc">RandomAccessList</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  
  <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">isEmpty</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  
  <span class="k">val</span> <span class="n">cons</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">head</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span>
  <span class="k">val</span> <span class="n">tail</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  
  <span class="k">val</span> <span class="n">lookup</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span>
  <span class="k">val</span> <span class="n">update</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div><p>We implement random-access lists using a binary numerical representation. A binary random-access list of size n contains
a tree for each one in the binary representation of n. We choose the simplest combination of features: complete binary
leaf trees and a dense representation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">digit</span> <span class="o">=</span> <span class="nc">Zero</span> <span class="o">|</span> <span class="nc">One</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">digit</span> <span class="kt">list</span>
</code></pre></td></tr></table>
</div>
</div><p>The integer in each <code>Node</code> is the size of the tree, this number is redundant. Trees are sorted in increasing order of size,
and the order of elements is left-to-right both within and between trees. The maximum number of trees in a list of size n
is log(n+1)(all position are one), and the maximum depth of any tree is logn. Inserting an element into a binary random-acess
list is analogous to increasing a binary number. The increment function on dense binary numbers like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">inc</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="nc">One</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">ds</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="o">::</span> <span class="n">ds</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="o">::</span> <span class="n">ds</span> <span class="o">-&gt;</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">inc</span> <span class="n">ds</span>
</code></pre></td></tr></table>
</div>
</div><p>Similarly, we first convert the element into a leaf, and then insert the leaf into the list follow the rule of <code>inc</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">1</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">_</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n</span>

<span class="k">let</span> <span class="n">link</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">size</span> <span class="n">t2</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span>

<span class="k">let</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">ts</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">consTree</span> <span class="n">t</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="nc">One</span> <span class="n">t</span><span class="o">]</span>
    <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="nc">One</span> <span class="n">t1</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">consTree</span> <span class="o">(</span><span class="n">link</span> <span class="n">t</span> <span class="n">t1</span><span class="o">)</span> <span class="n">tl</span>
  <span class="k">in</span>
  <span class="n">consTree</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="n">x</span><span class="o">)</span> <span class="n">ts</span>
</code></pre></td></tr></table>
</div>
</div><p>Deleting an element from a binary random-access list is analogous to decrementing a binary number:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="o">[</span><span class="nc">One</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="o">::</span> <span class="n">ds</span> <span class="o">-&gt;</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">ds</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">ds</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="o">::</span> <span class="n">dec</span> <span class="n">ds</span>
</code></pre></td></tr></table>
</div>
</div><p>So the implementation also follow the <code>dec</code> rule:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">unconsTree</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="o">[</span><span class="nc">One</span> <span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">,</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">,</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="k">match</span> <span class="o">(</span><span class="n">unconsTree</span> <span class="n">tl</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span><span class="o">,</span> <span class="n">ts</span> <span class="o">-&gt;</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">One</span> <span class="n">t2</span> <span class="o">::</span> <span class="n">ts</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">head</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">match</span> <span class="o">(</span><span class="n">unconsTree</span> <span class="n">ts</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="n">x</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">tail</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">match</span> <span class="o">(</span><span class="n">unconsTree</span> <span class="n">ts</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">_</span><span class="o">,</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">tl</span>
</code></pre></td></tr></table>
</div>
</div><p>The lookup and update functions do not have analogous arithmetic operations. Rather, they take advantage of the organization
of binary random-access lists as logarthmic-length lists of logarthmic-depth trees. Looking up or updating an element is
a two stage process, we first search the list for the correct tree, and then search the tree for the correct element. To
sum up we have:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(*</span><span class="c">*</span><span class="c"> randomAccessList.ml </span><span class="c">*)</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">digit</span> <span class="kt">list</span>
<span class="ow">and</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">digit</span> <span class="o">=</span> <span class="nc">Zero</span> <span class="o">|</span> <span class="nc">One</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
<span class="ow">and</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
                                     
<span class="k">exception</span> <span class="nc">Empty</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="k">function</span> 
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">1</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">_</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n</span>

<span class="k">let</span> <span class="n">link</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">size</span> <span class="n">t2</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span>

<span class="k">let</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">ts</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">consTree</span> <span class="n">t</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="nc">One</span> <span class="n">t</span><span class="o">]</span>
    <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="nc">One</span> <span class="n">t1</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">consTree</span> <span class="o">(</span><span class="n">link</span> <span class="n">t</span> <span class="n">t1</span><span class="o">)</span> <span class="n">tl</span>
  <span class="k">in</span>
  <span class="n">consTree</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="n">x</span><span class="o">)</span> <span class="n">ts</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">unconsTree</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="o">[</span><span class="nc">One</span> <span class="n">t</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">,</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">,</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="k">match</span> <span class="o">(</span><span class="n">unconsTree</span> <span class="n">tl</span><span class="o">)</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span><span class="o">,</span> <span class="n">ts</span> <span class="o">-&gt;</span> <span class="n">t1</span><span class="o">,</span> <span class="nc">One</span> <span class="n">t2</span> <span class="o">::</span> <span class="n">ts</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">head</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">match</span> <span class="o">(</span><span class="n">unconsTree</span> <span class="n">ts</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="n">x</span><span class="o">,</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">tail</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">match</span> <span class="o">(</span><span class="n">unconsTree</span> <span class="n">ts</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">_</span><span class="o">,</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">tl</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">t</span> <span class="o">=</span> <span class="k">match</span> <span class="n">i</span><span class="o">,</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span>
    <span class="k">then</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">left</span>
    <span class="k">else</span> <span class="n">lookupTree</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span><span class="o">)</span> <span class="n">right</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">t</span> <span class="o">=</span><span class="k">match</span> <span class="n">i</span><span class="o">,</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span>
    <span class="k">then</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
    <span class="k">else</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">updateTree</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span><span class="o">)</span> <span class="n">x</span> <span class="n">right</span><span class="o">)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">lookup</span> <span class="n">i</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">lookup</span> <span class="n">i</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> 
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t</span> 
    <span class="k">then</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">t</span>
    <span class="k">else</span> <span class="n">lookup</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t</span><span class="o">)</span> <span class="n">tl</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">update</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Zero</span> <span class="o">::</span> <span class="n">update</span> <span class="n">i</span> <span class="n">x</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> 
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t</span>
    <span class="k">then</span> <span class="nc">One</span> <span class="o">(</span><span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">update</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t</span><span class="o">)</span> <span class="n">x</span> <span class="n">tl</span>
</code></pre></td></tr></table>
</div>
</div><p>All operations run in O(logn) worst-case time. But <code>cons</code>, <code>head</code> and <code>tail</code> run in O(logn) not O(1) is one disappointing
aspect.</p>
<h3 id="zeroless-representation">zeroless representation</h3>
<p>Currently, <code>head</code> is implemented via a call to <code>unconsTree</code>, this approach yields compact code <code>unconsTree</code> supports both
<code>head</code> and <code>tail</code>, but wastes time building lists that are immediately discard by <code>head</code>. For greater efficiency, we should
implement <code>head</code> directly. As a special case, <code>head</code> can easily be made to run in O(1) time whenever the first digit is
non-zero. So we seek to arrange that the first digit is always non-zero, one more principled solution is to use a zeroless
representation, in which binary numbers are constructed from ones and twos instead of zeros and ones:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="n">nat</span> <span class="o">=</span> <span class="n">digit</span> <span class="kt">list</span>
<span class="ow">and</span> <span class="n">digit</span> <span class="o">=</span> <span class="nc">One</span> <span class="o">|</span> <span class="nc">Two</span>

<span class="k">let</span> <span class="n">inc</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="nc">One</span><span class="o">]</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="o">::</span> <span class="n">ds</span> <span class="o">-&gt;</span> <span class="nc">Two</span> <span class="o">::</span> <span class="n">ds</span>
  <span class="o">|</span> <span class="nc">Two</span> <span class="o">::</span> <span class="n">ds</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="o">::</span> <span class="n">inc</span> <span class="n">ds</span>
</code></pre></td></tr></table>
</div>
</div><p>And the implementation of random-access list is:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="c">(*</span><span class="c">*</span><span class="c"> randomAccessListZeroless.ml 
</span><span class="c">  </span><span class="c">*</span><span class="c"> the interface is same as RandomAccessList </span><span class="c">*)</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">digit</span> <span class="kt">list</span>
<span class="ow">and</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">digit</span> <span class="o">=</span> <span class="nc">One</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">|</span> <span class="nc">Two</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
<span class="ow">and</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>

<span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

<span class="k">exception</span> <span class="nc">Empty</span>

<span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">1</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">_</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n</span>

<span class="k">let</span> <span class="n">link</span> <span class="n">t1</span> <span class="n">t2</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">size</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">size</span> <span class="n">t2</span><span class="o">,</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span>

<span class="k">let</span> <span class="n">cons</span> <span class="n">x</span> <span class="n">ts</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">consTree</span> <span class="n">t</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="nc">One</span> <span class="n">t</span><span class="o">]</span>
    <span class="o">|</span> <span class="nc">One</span> <span class="n">t1</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">t1</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="o">|</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">consTree</span> <span class="o">(</span><span class="n">link</span> <span class="n">t1</span> <span class="n">t2</span><span class="o">)</span> <span class="n">tl</span>
  <span class="k">in</span> <span class="n">consTree</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="n">x</span><span class="o">)</span> <span class="n">ts</span>

<span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="nc">Leaf</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="nc">Two</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="n">x</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="o">[</span><span class="nc">One</span> <span class="o">_</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="o">_</span> <span class="o">::</span> <span class="nc">One</span> <span class="nc">Node</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="o">_</span> <span class="o">::</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">::</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">Two</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">assert</span> <span class="bp">false</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">t</span> <span class="o">=</span> <span class="k">match</span> <span class="n">i</span><span class="o">,</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span>
    <span class="k">then</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">left</span>
    <span class="k">else</span> <span class="n">lookupTree</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span><span class="o">)</span> <span class="n">right</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">t</span> <span class="o">=</span><span class="k">match</span> <span class="n">i</span><span class="o">,</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">0</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">Leaf</span> <span class="n">x</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="n">i</span><span class="o">,</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span>
    <span class="k">then</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span>
    <span class="k">else</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">updateTree</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">n</span> <span class="o">/</span> <span class="n">2</span><span class="o">)</span> <span class="n">x</span> <span class="n">right</span><span class="o">)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">lookup</span> <span class="n">i</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="nc">One</span> <span class="n">t</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t</span>
    <span class="k">then</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">t</span>
    <span class="k">else</span> <span class="n">lookup</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t</span><span class="o">)</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t1</span> 
    <span class="k">then</span> <span class="n">lookupTree</span> <span class="n">i</span> <span class="n">t1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t2</span>
    <span class="k">then</span> <span class="n">lookupTree</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t1</span><span class="o">)</span> <span class="n">t2</span>
    <span class="k">else</span> <span class="n">lookup</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t2</span><span class="o">)</span> <span class="n">tl</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">update</span> <span class="n">i</span> <span class="n">x</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">Empty</span>
  <span class="o">|</span> <span class="o">(</span><span class="nc">One</span> <span class="n">t</span> <span class="k">as</span> <span class="n">hd</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t</span> 
    <span class="k">then</span> <span class="nc">One</span> <span class="o">(</span><span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">t</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">update</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t</span><span class="o">)</span> <span class="n">x</span> <span class="n">tl</span>
  <span class="o">|</span> <span class="o">(</span><span class="nc">Two</span> <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="k">as</span> <span class="n">hd</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t1</span>
    <span class="k">then</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">updateTree</span> <span class="n">i</span> <span class="n">x</span> <span class="n">t1</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="n">t2</span>
    <span class="k">then</span> <span class="nc">Two</span> <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">updateTree</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t1</span><span class="o">)</span> <span class="n">x</span> <span class="n">t2</span><span class="o">)</span> <span class="o">::</span> <span class="n">tl</span>
    <span class="k">else</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">update</span> <span class="o">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">size</span> <span class="n">t2</span><span class="o">)</span> <span class="n">x</span> <span class="n">tl</span>
</code></pre></td></tr></table>
</div>
</div><p>Now the <code>head</code> and <code>tail</code> take O(1) time.</p>
<h2 id="datastructural-bootstrapping">data-structural bootstrapping</h2>
<p>The term &ldquo;bootstrapping&rdquo; refers to solving problems via solving simple instance of the same problem. And there are three
algorithmic design techniques of data-structural bootstrapping. The first, <em>structural decomposition</em>, involves bootstrapping
complete data structures from incomplete data structures. The second, <em>structural abstraction</em>, involves bootstrapping
efficient data structures from inefficient data structures. The last bootstrapping data structures with aggregate elements
from data structures with atomic elements.</p>
<h3 id="structural-decomposition">structural decomposition</h3>
<p>Typically <em>structural decomposition</em> involves taking an implementation can handle objects only up to some bound size, and
extending it to handle objects of unbounded size. Consider typical recursive datatypes such as lists and binary leaf trees:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="kt">list</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
</code></pre></td></tr></table>
</div>
</div><p>In some ways, these can be regarded as instances of some bounded size(zero for lists and one fo tree) and a rule for
recursively decomposing larger objects into smaller objects until eventually each object is small enough to be handled
by the bounded case.</p>
<p>However, both of these definitions are particularly simple that the recursive component in each definition is identical
to the type being defined, which called <em>uniformly recursive</em>. In general, we reserve the term <em>structural decomposition</em>
to describe recursive data structure that are <em>non-uniform</em> for cases that the recursive component is different from its
definition, e.g. <code>type 'a seq = Nil | Cons of 'a * ('a * 'a) seq</code>. But you can not implement structural decomposition
directly in ML, althought it allows the definition of non-uniform recursive datatypes. But the type system always disallow
the functions on such types like below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="o">(</span><span class="k">type</span> <span class="n">illegal</span><span class="o">)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">size</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Nil</span> <span class="o">-&gt;</span> <span class="n">0</span>
  <span class="o">|</span> <span class="nc">Cons</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ps</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">1</span> <span class="o">+</span> <span class="n">2</span> <span class="o">*</span> <span class="n">size</span> <span class="n">ps</span>
</code></pre></td></tr></table>
</div>
</div><p>Fortunately it is always possible to convert a non-uniform type into a uniform type by introducing a new datatype to
collapse the different instances into a single type, for example, we can rewrite the <code>seq</code> as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ep</span> <span class="o">=</span> <span class="nc">Elem</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Pair</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ep</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ep</span>
<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">seq</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ep</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">seq</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that the <code>'a ep</code> type is isomorphic to binary leaf trees, so the version of <code>'a seq</code> is equivalent to <code>'a tree list</code>,
though we would tend to think a list of trees differently that we would think of a sequence of pairs &ndash; some algorithms
will seem simpler or more natural for one of the representations, and some for the other.</p>
<p>To use sequence represent positional number system, we need to represent zero, it's easily corrected by adding another
constructor of the type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">seq</span> <span class="o">=</span> 
   <span class="o">|</span> <span class="nc">Nil</span>
   <span class="o">|</span> <span class="nc">Zero</span> <span class="k">of</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="n">seq</span>
   <span class="o">|</span> <span class="nc">One</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="n">seq</span>
</code></pre></td></tr></table>
</div>
</div><p>Now we can represent the sequence 0&hellip;10 as <code>One(0, One((1, 2), Zero(One((((3, 4), (5, 6)), ((7, 8), (9, 10))), Nil))))</code>,
which has 11 elements, written 1101 in binary. The pairs in this type are always balanced. In fact, another way to think
of pairs of elements is as complete binary leaf trees. And then we can replement binary random-access lists use this type.</p>
<h3 id="tries">tries</h3>
<p>Binary search trees work well when comparisons on the key or element type are cheap. This is true for simple types like
integers or characters, but may not be true for aggregate types like strings. A better solution for aggregate types such
as string is to choose a representation that takes advantage of the structure of that type. One such representation is
<em>tries</em>, also known as a <em>digital search trees</em>.</p>
<p>A trie is a multiway tree where each edge is labelled with a character. Edges leaving the root of a trie represent the
first character of a string, and so on. and if the node is vaild, which means it contains a value, we can mark it as
<code>Some x</code>, otherwise <code>None</code>. The critical remaining question is how to represent the edges leaving a node, we can represent
edges as a vector, an association list, a binary search tree, or even another trie. But all of these are just finite maps
from edges labels to tries. So we can use a given structure Map implementing finite maps over base type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Trie</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">option</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="nc">Map</span> <span class="nn">Map</span><span class="p">.</span><span class="n">t</span>
</code></pre></td></tr></table>
</div>
</div><p>Thus we can implement Trie as a functor from finiteMap to finiteMap:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-ocaml" data-lang="ocaml"><span class="k">module</span> <span class="k">type</span> <span class="nc">FiniteMap</span> <span class="o">=</span> <span class="k">sig</span>
  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">type</span> <span class="n">key</span>

  <span class="k">exception</span> <span class="nc">NotFound</span>

  <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">bind</span> <span class="o">:</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span>
  <span class="k">val</span> <span class="n">lookup</span> <span class="o">:</span> <span class="n">key</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="k">&#39;</span><span class="n">a</span>
    
<span class="k">end</span>

<span class="k">module</span> <span class="nc">Make</span> <span class="o">(</span><span class="nc">Map</span> <span class="o">:</span> <span class="nc">FiniteMap</span><span class="o">)</span> <span class="o">:</span> <span class="nc">FiniteMap</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">key</span> <span class="o">=</span> <span class="nn">Map</span><span class="p">.</span><span class="n">key</span> <span class="kt">list</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Trie</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">option</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">t</span> <span class="nn">Map</span><span class="p">.</span><span class="n">t</span>

  <span class="k">exception</span> <span class="nc">NotFound</span>

  <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nc">Trie</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nn">Map</span><span class="p">.</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">lookup</span> <span class="n">key</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">match</span> <span class="n">key</span><span class="o">,</span> <span class="n">trie</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="nc">Trie</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="nc">NotFound</span>
    <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="nc">Trie</span> <span class="o">(</span><span class="nc">Some</span> <span class="n">x</span><span class="o">,</span> <span class="o">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">k</span> <span class="o">::</span> <span class="n">ks</span><span class="o">,</span> <span class="nc">Trie</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">lookup</span> <span class="n">ks</span> <span class="o">(</span><span class="nn">Map</span><span class="p">.</span><span class="n">lookup</span> <span class="n">k</span> <span class="n">m</span><span class="o">)</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">bind</span> <span class="n">key</span> <span class="n">x</span> <span class="n">trie</span> <span class="o">=</span> <span class="k">match</span> <span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">trie</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Trie</span> <span class="o">(</span><span class="o">_</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Trie</span> <span class="o">(</span><span class="nc">Some</span> <span class="n">x</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>
    <span class="o">|</span> <span class="n">k</span> <span class="o">::</span> <span class="n">ks</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Trie</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> 
      <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> 
        <span class="k">try</span> <span class="nn">Map</span><span class="p">.</span><span class="n">lookup</span> <span class="n">k</span> <span class="n">m</span>
        <span class="k">with</span> <span class="nc">NotFound</span> <span class="o">-&gt;</span> <span class="n">empty</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">t&#39;</span> <span class="o">=</span> <span class="n">bind</span> <span class="n">ks</span> <span class="n">x</span> <span class="n">t</span> <span class="k">in</span>
      <span class="nc">Trie</span> <span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="nn">Map</span><span class="p">.</span><span class="n">bind</span> <span class="n">k</span> <span class="n">t&#39;</span> <span class="n">m</span><span class="o">)</span>

<span class="k">end</span>
</code></pre></td></tr></table>
</div>
</div>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>functional data structure 2</b><nav id="TableOfContents">
  <ul>
    <li><a href="#amortization">amortization</a>
      <ul>
        <li><a href="#queue">queue</a></li>
        <li><a href="#splay-heaps">splay heaps</a></li>
        <li><a href="#pairing-heaps">pairing heaps</a></li>
      </ul>
    </li>
    <li><a href="#numerical-representations">numerical representations</a>
      <ul>
        <li><a href="#binary-randomaccess-lists">binary random-access lists</a></li>
        <li><a href="#zeroless-representation">zeroless representation</a></li>
      </ul>
    </li>
    <li><a href="#datastructural-bootstrapping">data-structural bootstrapping</a>
      <ul>
        <li><a href="#structural-decomposition">structural decomposition</a></li>
        <li><a href="#tries">tries</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    Christophe &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
