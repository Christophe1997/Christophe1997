<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on CastOff</title>
    <link>https://christophe1997.github.io/tags/java/</link>
    <description>Recent content in Java on CastOff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>&amp;copy;Christophe</copyright>
    <lastBuildDate>Fri, 05 Jun 2020 20:27:43 +0800</lastBuildDate>
    
	<atom:link href="https://christophe1997.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Effective Java 2</title>
      <link>https://christophe1997.github.io/posts/effective-java-2/</link>
      <pubDate>Fri, 05 Jun 2020 20:27:43 +0800</pubDate>
      
      <guid>https://christophe1997.github.io/posts/effective-java-2/</guid>
      <description>&amp;ldquo;effective Java&amp;quot;的第二部分总结, 内容主要关于Object的可重写的方法(equals, toString, hashCode, clone, finalize)以及类和接口的使用。 Ob</description>
    </item>
    
    <item>
      <title>Effective Java 1</title>
      <link>https://christophe1997.github.io/posts/effective-java-1/</link>
      <pubDate>Thu, 04 Jun 2020 20:53:58 +0800</pubDate>
      
      <guid>https://christophe1997.github.io/posts/effective-java-1/</guid>
      <description>&amp;ldquo;Effective Java&amp;quot;的第一部分(对象的创建与销毁)总结. 用static的方法(静态工厂方法)代替构造函数创建对象 优点: 可以有更合理的方法名</description>
    </item>
    
    <item>
      <title>字符串处理算法</title>
      <link>https://christophe1997.github.io/posts/string-algorithms/</link>
      <pubDate>Mon, 07 May 2018 21:18:59 +0000</pubDate>
      
      <guid>https://christophe1997.github.io/posts/string-algorithms/</guid>
      <description>字符串处理算法具有很高的重要性以及应用领域的多样性. 以下讨论默认的是扩展的ASCII字符集(R=256). 字符串排序算法 对于许多排序应用而言</description>
    </item>
    
    <item>
      <title>图算法</title>
      <link>https://christophe1997.github.io/posts/graph-algorithms/</link>
      <pubDate>Fri, 20 Apr 2018 19:21:30 +0000</pubDate>
      
      <guid>https://christophe1997.github.io/posts/graph-algorithms/</guid>
      <description>采用哪种数据结构来表示图, 主要考虑以下两个方面: 必须为可能在应用中碰到的各种类型的图预留出足够的空间, 以及 Graph的实例方法一定要高效. 常</description>
    </item>
    
    <item>
      <title>查找算法</title>
      <link>https://christophe1997.github.io/posts/search-algorithms/</link>
      <pubDate>Thu, 05 Apr 2018 15:21:41 +0000</pubDate>
      
      <guid>https://christophe1997.github.io/posts/search-algorithms/</guid>
      <description>符号表是一种存储键值对的数据结构, 支持插入和查找操作. 要确定一个给定的键是否存在于符号表中, 首先要建立对象等价性的概念. 为了保证一致性, 最好</description>
    </item>
    
    <item>
      <title>优先队列</title>
      <link>https://christophe1997.github.io/posts/priority-queue/</link>
      <pubDate>Wed, 04 Apr 2018 16:18:50 +0000</pubDate>
      
      <guid>https://christophe1997.github.io/posts/priority-queue/</guid>
      <description>优先队列 当一颗二叉树的每个节点都大于等于它的两个子结点时, 它被称为堆有序, 于是从任一结点向上都能够得到一列非递减的元素. 二叉堆(以下简称堆)</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://christophe1997.github.io/posts/sorting-algorithms/</link>
      <pubDate>Fri, 30 Mar 2018 12:07:09 +0000</pubDate>
      
      <guid>https://christophe1997.github.io/posts/sorting-algorithms/</guid>
      <description>排序算法的目标就是将所有元素的主键按照某种方式排列. 成本模型: 计算比较和交换的次数, 对于不交换元素的算法, 计算访问数组的次数. 排序算法的额外</description>
    </item>
    
    <item>
      <title>union-find算法</title>
      <link>https://christophe1997.github.io/posts/union-find-algorithm/</link>
      <pubDate>Wed, 14 Mar 2018 22:54:16 +0000</pubDate>
      
      <guid>https://christophe1997.github.io/posts/union-find-algorithm/</guid>
      <description>union-find算法是一个解决动态连通性的经典算法, 具有广泛性的应用. 简单起见, 我们将对象称为触点, 将整数对称为连接, 将等价类称为连通分</description>
    </item>
    
  </channel>
</rss>